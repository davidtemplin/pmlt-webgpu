<html>
    <script type="module">
        const KEYS = [
    '0xc8e4fd154ce32f6d',
    '0xfcbd6e154bf53ed9',
    '0xea6342c76bf95d47',
    '0xfb9e125878fa6cb3',
    '0xa1ed294ba7fe8b31',
    '0xcf29ba8dc5f1a98d',
    '0x815a7d4ed4e3b7f9',
    '0x163acbf213f5d867',
    '0x674e2d1542f9e6d3',
    '0xebc9672872ecf651',
    '0xec13a6976ecf14ad',
    '0x42c86e3a9de3542b',
    '0x5489de2cbce65297',
    '0x49bc37fdcad971f3',
    '0xd5b4213fe7db8f61',
    '0xbf785e3215ac7ebd',
    '0x46be329546e1ad3b',
    '0x8b7ef19654e3dca7',
    '0x1d7683c983d7eb15',
    '0x3724b1c872d9fa81',
    '0x2af73db87fab18ed',
    '0xa185f4cbadcf285b',
    '0x53d684c1fbd246c7',
    '0x35fda1821cd68735',
    '0xfd3791543bd985a1',
    '0x7f59c4b657cb941f',
    '0x19f3e5b765cea27b',
    '0xf6235eca95b2c1e7',
    '0x9d827c5ba2b3df45',
    '0x8a149e2dc2a6feb1',
    '0xa9234cbdcea91d2f',
    '0xab134cd21f9c2d8b',
    '0x65c48e132c9e3bf7',
    '0x7e943bd54dc26b75',
    '0x4b3a29d76ab579d1',
    '0xfa2871eba6b7984f',
    '0x4bd2596ed48c96ab',
    '0xa9463c1ed4aec629',
    '0x39a5fc81f3b1e495',
    '0x72f9c8a323a5e4f1',
    '0xb7cf8a2652b8136f',
    '0xb372ac465f8932db',
    '0x16dab9f87ead5149',
    '0xaf9ed4c87b8e4fa5',
    '0xbcae598dcba48e13',
    '0xd3bc94fed6948c7f',
    '0xbacd24f1f4768aeb',
    '0xfeca9382147acb59',
    '0xf4a18b53237ed9c5',
    '0xfa96251875a1f943',
    '0xb247ef5982a4179f',
    '0x695781dbaf98371d',
    '0x782ae64dce8b3579',
    '0xad5b918edb8c64e5',
    '0x4e98ac3feb9f8463',
    '0xd1bc48f21a7382bf',
    '0xa763b9e54986a13d',
    '0x9d3fe5643456bf89',
    '0x7acf9b287369bdf5',
    '0x7f4823ba926ced73',
    '0x5acef64ba3721bcf',
    '0x8af4673dcf752b4d',
    '0x2bc59ae1fe563ab9',
    '0xb639dc821e6b5a27',
    '0x71d692e32c5d6893',
    '0x8ec7d3f4394d76ef',
    '0x6cf18d298972a56d',
    '0xa1c698dba765b4d9',
    '0x527f618dc569d347',
    '0x167d892ed46ae2b3',
    '0x63547dbfe47df231',
    '0xf84de9565472318d',
    '0xa8e4dc232d543fe9',
    '0x89f56da76d384e57',
    '0x42ea36b87b496dc3',
    '0x17fd98ba9a5d8c41',
    '0x763f529cb63f7a9d',
    '0xe8794dcfe753c91b',
    '0xd7e4f9c1f534d987',
    '0x5fa74d621548d7e3',
    '0x783c12e6534bf761',
    '0xe7c435b8724e15bd',
    '0xc1258b6a9f61453b',
    '0xae842f6cbe2453a7',
    '0x176f8e4dcd498315',
    '0xc48512bfec4b9281',
    '0x8bd269cfe62a7fcd',
    '0x7fbe5932172f9e4b',
    '0x34fa7d954632cdb7',
    '0xad1b36598736ec25',
    '0xc471f3598437fb91',
    '0xfec831d9823a19fd',
    '0x58f9746baf1e296b',
    '0xeb6a512dce2148d7',
    '0x635c9b81fd137845',
    '0xe32f6dc43d2786b1',
    '0x924ec7a54b1a952f',
    '0x74af9cd6571da38b',
    '0x3bc5d689861eb2f7',
    '0xfb6da23cb823e175',
];

class KeyUtil {
    static parse(key) {
        const hi = parseInt(key.substring(2, 10), 16);
        const lo = parseInt(key.substring(10), 16);
        return { hi, lo };
    }
}

class Config {
    pathLog = {
        enabled: true,
        targetIndex: 94,
    };

    bindGroup = {
        primary: {
            index: 0,
            binding: {
                camera: 0,
                sphere: 1,
                chain: 2,
                path: 3,
                image: 4,
                queue: 5,
                pathLog: 6,
            },
        },
        auxiliary: {
            index: 1,
            binding: {
                dispatchIndirectParameters: 0,
            },
        },
        uniform: {
            index: 2,
            binding: {
                parameters: 0,
            },
        },
    };

    random = {
        counts: {
            vertex: 4,
        },
    };

    path = {
        count: 1_000_000,
        length: {
            min: 2,
            max: 6,
        },
    };

    queue = {
        count: 11,
        index: {
            sample: {
                camera: 0,
                light: 1,
                material: 2,
            },
            intersect: 3,
            connect: 4,
            postConnect: {
                camera: {
                    direct: 5,
                    indirect: 6,
                },
                light: {
                    direct: 7,
                    indirect: 8,
                },
                null: 9,
            },
            contribute: 10,
        },
    };

    sphere = {
        count: 10,
        id: {
            light: 0,
        },
    };

    workgroup = {
        size: 64,
    };

    image = {
        width: 640,
        height: 480,
    };
    
    memory = {
        limit: 2_147_483_644,
    };
}

const config = new Config();

const WGSL_LIB_CODE = `
const CAMERA_STREAM_INDEX: u32 = 0;
const LIGHT_STREAM_INDEX: u32 = 1;
const TECHNIQUE_STREAM_INDEX: u32 = 2;

const PI: f32 = 3.14159265358979323846264338327950288;

const NUMBERS_PER_VERTEX: u32 = ${config.random.counts.vertex};
const MIN_PATH_LENGTH: u32 = 2;
const MAX_PATH_LENGTH: u32 = ${config.path.length.max};

const QUEUE_COUNT: u32 = ${config.queue.count};

const NULL_QUEUE_ID: u32 = 1000;
const SAMPLE_CAMERA_QUEUE_ID: u32 = ${config.queue.index.sample.camera};
const SAMPLE_LIGHT_QUEUE_ID: u32 = ${config.queue.index.sample.light};
const INTERSECT_QUEUE_ID: u32 = ${config.queue.index.intersect};
const SAMPLE_MATERIAL_QUEUE_ID: u32 = ${config.queue.index.sample.material};
const CONNECT_QUEUE_ID: u32 = ${config.queue.index.connect};
const POST_CONNECT_CAMERA_DIRECT_QUEUE_ID: u32 = ${config.queue.index.postConnect.camera.direct};
const POST_CONNECT_CAMERA_INDIRECT_QUEUE_ID: u32 = ${config.queue.index.postConnect.camera.indirect};
const POST_CONNECT_LIGHT_DIRECT_QUEUE_ID: u32 = ${config.queue.index.postConnect.light.direct};
const POST_CONNECT_LIGHT_INDIRECT_QUEUE_ID: u32 = ${config.queue.index.postConnect.light.indirect};
const POST_CONNECT_NULL_QUEUE_ID: u32 = ${config.queue.index.postConnect.null};
const CONTRIBUTE_QUEUE_ID: u32 = ${config.queue.index.contribute};

const LIGHT_SPHERE_ID: u32 = ${config.sphere.id.light};

const PATH_COUNT: u32 = ${config.path.count};
const SPHERE_COUNT: u32 = ${config.sphere.count};

const LARGE_STEP_PROBABILITY = 0.3;
const SMALL_STEP_PROBABILITY = 1.0 - LARGE_STEP_PROBABILITY;
const SMALL_STEP: u32 = 0;
const LARGE_STEP: u32 = 1;
const CHAIN_COUNT: u32 = MAX_PATH_LENGTH - MIN_PATH_LENGTH + 1;
const WORKGROUP_SIZE: u32 = ${config.workgroup.size};

const CAMERA_GROUP: u32 = ${config.bindGroup.primary.index}; 
const CAMERA_BINDING: u32 = ${config.bindGroup.primary.binding.camera};
const SPHERE_GROUP: u32 = ${config.bindGroup.primary.index};
const SPHERE_BINDING: u32 = ${config.bindGroup.primary.binding.sphere};
const CHAIN_GROUP: u32 = ${config.bindGroup.primary.index};
const CHAIN_BINDING: u32 = ${config.bindGroup.primary.binding.chain};
const PATH_GROUP: u32 = ${config.bindGroup.primary.index};
const PATH_BINDING: u32 = ${config.bindGroup.primary.binding.path};
const IMAGE_GROUP: u32 = ${config.bindGroup.primary.index};
const IMAGE_BINDING: u32 = ${config.bindGroup.primary.binding.image};
const QUEUE_GROUP: u32 = ${config.bindGroup.primary.index};
const QUEUE_BINDING: u32 = ${config.bindGroup.primary.binding.queue}; 
const PATH_LOG_GROUP: u32 = ${config.bindGroup.primary.index};
const PATH_LOG_BINDING: u32 = ${config.bindGroup.primary.binding.pathLog};
const DISPATCH_INDIRECT_PARAMETERS_GROUP: u32 = ${config.bindGroup.auxiliary.index}; 
const DISPATCH_INDIRECT_PARAMETERS_BINDING: u32 = ${config.bindGroup.auxiliary.binding.dispatchIndirectParameters};
const UNIFORM_GROUP: u32 = ${config.bindGroup.uniform.index};
const UNIFORM_BINDING: u32 = ${config.bindGroup.uniform.binding.parameters};

const PIXEL_WIDTH: u32 = ${config.image.width};
const PIXEL_HEIGHT: u32 = ${config.image.height};
const PIXEL_COUNT: u32 = PIXEL_WIDTH * PIXEL_HEIGHT;

const SIGMA: f32 = 0.01;
const MAX_F32: f32 = 3.40282346638528859812e+38f;

const CAMERA: u32 = 0;
const LIGHT: u32 = 1;

const ULTIMATE: u32 = 0;
const PENULTIMATE: u32 = 1;

const HI: u32 = 0;
const LO: u32 = 1;

const PROPOSAL: u32 = 0;
const CURRENT: u32 = 1;

const FIXED_POINT_SCALE: f32 = 1048576.0;

const PATH_LOG_TARGET_INDEX: u32 = ${config.pathLog.targetIndex};
const PATH_LOG_ENABLED: bool = ${config.pathLog.enabled};

struct Camera {
    u: vec3f,
    v: vec3f,
    w: vec3f,
    origin: vec3f,
    distance: f32,
};

struct Sphere {
    radius: array<f32, SPHERE_COUNT>,
    center: array<array<f32, SPHERE_COUNT>, 3>,
    color: array<array<f32, SPHERE_COUNT>, 3>,
};

struct Path {
    /* path context */
    step_type: array<u32, PATH_COUNT>,
    index: array<u32, PATH_COUNT>,
    length: array<u32, PATH_COUNT>,
    vertex_index: array<u32, PATH_COUNT>,
    technique: array<array<u32, PATH_COUNT>, 2>,

    /* ray */
    ray_origin: array<array<f32, PATH_COUNT>, 3>,
    ray_direction: array<array<f32, PATH_COUNT>, 3>,

    /* beta */
    beta: array<array<f32, PATH_COUNT>, 3>,

    /* pixel */
    pixel: array<array<u32, PATH_COUNT>, 2>,

    /* CDF */
    cdf: array<f32, PATH_COUNT>,

    /* geometry */
    point: array<array<array<array<f32, PATH_COUNT>, 3>, 2>, 2>,
    normal: array<array<array<array<f32, PATH_COUNT>, 3>, 2>, 2>,

    /* material */
    material_id: array<array<u32, PATH_COUNT>, 2>,

    /* MIS */
    pdf_fwd: array<array<array<f32, PATH_COUNT>, 2>, 2>,
    sum_inv_ri: array<array<f32, PATH_COUNT>, 2>,
    prod_ri: array<array<f32, PATH_COUNT>, 2>,

    /* PDF */
    directional_pdf: array<f32, PATH_COUNT>,

    final_ri: array<f32, PATH_COUNT>,
};

struct U64 {
  hi: u32,
  lo: u32,
};

struct Technique {
    camera: u32,
    light: u32,
};

struct Basis {
    u: vec3f,
    v: vec3f,
    w: vec3f,
};

struct Chain {
    key: array<array<u32, CHAIN_COUNT>, 2>,
    iteration: array<u32, CHAIN_COUNT>,
    numbers_per_iteration: array<u32, CHAIN_COUNT>,
    numbers_per_path: array<u32, CHAIN_COUNT>,
    numbers_per_stream: array<u32, CHAIN_COUNT>,
    large_step_index: array<array<u32, CHAIN_COUNT>, 2>,
    small_step_count: array<u32, CHAIN_COUNT>,
    b: array<f32, CHAIN_COUNT>,
    pdf: array<f32, CHAIN_COUNT>,
    min_small_step_index: array<u32, CHAIN_COUNT>,
    max_small_step_index: array<u32, CHAIN_COUNT>,
    contribution: array<array<f32, CHAIN_COUNT>, 3>,
    scalar_contribution: array<f32, CHAIN_COUNT>,
    min_path_index: array<u32, CHAIN_COUNT>,
    path_count: array<u32, CHAIN_COUNT>,
};

struct RandomParameters {
  step_type: u32,
  local_path_index: u32,
  numbers_per_path: u32,
  stream_index: u32,
  numbers_per_stream: u32,
  vertex_index: u32,
  iteration: u32,
  numbers_per_iteration: u32,
  large_step_index: U64,
  key: U64,
  small_step_count: u32,
};

struct Image {
    pixels: array<array<array<atomic<u32>, PIXEL_WIDTH>, PIXEL_HEIGHT>, 3>,
};

struct Queue {
    index: array<array<u32, PATH_COUNT>, QUEUE_COUNT>,
    count: array<atomic<u32>, QUEUE_COUNT>,
};

struct InitializeUniforms {
    path_length: u32,
};

struct ClearQueueUniforms {
    queue_id: u32,
}

struct BuildCdfUniforms {
    chain_id: u32,
    iteration: u32,
};

struct StartChainUniforms {
    chain_id: u32,
    random: f32,
};

struct UpdateChainUniforms {
    chain_id: u32,
    random: f32,
};

struct Intersection {
    point: vec3f,
    normal: vec3f,
    sphere_id: u32,
    valid: bool,
};

struct Ray {
    origin: vec3f,
    direction: vec3f,
};

struct PixelCoordinates {
    x: u32,
    y: u32,
    valid: bool,
};

struct MaterialSample {
    wi: vec3f,
    pdf_fwd: f32,
    pdf_rev: f32,
    throughput: vec3f,
    valid: bool,
};

struct CameraSample {
    point: vec3f,
    direction: vec3f,
    normal: vec3f,
    positional_pdf: f32,
    directional_pdf: f32,
    x: u32,
    y: u32,
};

struct LightSample {
    point: vec3f,
    direction: vec3f,
    normal: vec3f,
    positional_pdf: f32,
    directional_pdf: f32,
};

struct MaterialEvaluation {
    pdf_fwd: f32,
    pdf_rev: f32,
    throughput: vec3f,
    valid: bool,
};

struct VertexLog {
    point: vec3f,
    normal: vec3f,
    direction: vec3f,
    sphere_id: u32,
};

struct PathLog {
    vertices: array<VertexLog, MAX_PATH_LENGTH>,
    beta: vec3f,
    mis_weight: f32,
    foo: f32,
};

@group(CAMERA_GROUP) @binding(CAMERA_BINDING) var<storage, read> camera: Camera;
@group(SPHERE_GROUP) @binding(SPHERE_BINDING) var<storage, read> sphere: Sphere;
@group(CHAIN_GROUP) @binding(CHAIN_BINDING) var<storage, read_write> chain: Chain;
@group(PATH_GROUP) @binding(PATH_BINDING) var<storage, read_write> path: Path;
@group(IMAGE_GROUP) @binding(IMAGE_BINDING) var<storage, read_write> image: Image;
@group(QUEUE_GROUP) @binding(QUEUE_BINDING) var<storage, read_write> queue: Queue;
@group(DISPATCH_INDIRECT_PARAMETERS_GROUP) @binding(DISPATCH_INDIRECT_PARAMETERS_BINDING) var<storage, read_write> dispatch_indirect_parameters: array<vec3u, QUEUE_COUNT>;

var<workgroup> workgroup_queue_ballot: array<u32, WORKGROUP_SIZE>;
var<workgroup> workgroup_global_path_index: array<u32, WORKGROUP_SIZE>;

@group(PATH_LOG_GROUP) @binding(PATH_LOG_BINDING) var<storage, read_write> path_log: PathLog;

fn rand(p: RandomParameters, number_index: u32) -> f32 {
    let stream_offset = p.stream_index * p.numbers_per_stream 
      +  p.vertex_index * NUMBERS_PER_VERTEX 
      + number_index;
    let path_offset = p.local_path_index * p.numbers_per_path + stream_offset;
    let index = u64_add(u64_mul(u64_from(p.iteration), u64_from(p.numbers_per_iteration)), u64_from(path_offset));
    let random_number = squares32(index, p.key);
    if  p.step_type == LARGE_STEP {
        return random_number;
    } else {
        let index = u64_add(p.large_step_index, u64_from(stream_offset));
        let value = squares32(index, p.key);
        let perturbation = SIGMA
          * sqrt(f32(p.small_step_count)) 
          * sqrt(2.0) 
          * erf_inv(2.0 * random_number - 1.0);
        return value + perturbation;
    }
}

fn get_random_parameters(global_path_index: u32, stream_index: u32) -> RandomParameters {
  let path_length = path.length[global_path_index];
  let chain_index = path_length - MIN_PATH_LENGTH;
  let step_type = path.step_type[global_path_index];
  let local_path_index = path.index[global_path_index];
  let vertex_index = path.vertex_index[global_path_index];
  return RandomParameters(
    step_type, 
    local_path_index, 
    chain.numbers_per_path[chain_index], 
    stream_index, 
    chain.numbers_per_stream[chain_index], 
    vertex_index, 
    chain.iteration[chain_index], 
    chain.numbers_per_iteration[chain_index], 
    U64(chain.large_step_index[HI][chain_index], chain.large_step_index[LO][chain_index]),
    U64(chain.key[HI][chain_index], chain.key[LO][chain_index]),
    chain.small_step_count[chain_index]
  );
}

fn rand_1(global_path_index: u32, stream_index: u32) -> f32 {
  let p = get_random_parameters(global_path_index, stream_index);
  return rand(p, 0);
}

fn rand_2(global_path_index: u32, stream_index: u32) -> vec2f {
  let p = get_random_parameters(global_path_index, stream_index);
  let r1 = rand(p, 0);
  let r2 = rand(p, 1);
  return vec2f(r1, r2);
}

fn rand_4(global_path_index: u32, stream_index: u32) -> vec4f {
  let p = get_random_parameters(global_path_index, stream_index);
  let r1 = rand(p, 0);
  let r2 = rand(p, 1);
  let r3 = rand(p, 2);
  let r4 = rand(p, 3);
  return vec4f(r1, r2, r3, r4);
}

fn u64_from(lo: u32) -> U64 {
    return U64(0, lo);
}

fn squares32(ctr: U64, key: U64) -> f32 {
  var x = u64_mul(ctr, key);
  var y = x;
  var z = u64_add(y, key);

  x = squares32_round(x, y);
  x = squares32_round(x, z);
  x = squares32_round(x, y);
  x = squares32_round(x, z);

  return squares32_bitcast(x.hi);
}

fn squares32_bitcast(u: u32) -> f32 {
  return bitcast<f32>((u >> 9) | 0x3f800000) - 1.0;
}

fn squares32_round(a: U64, b: U64) -> U64 {
  return u64_swp(u64_add(u64_sqr(a), b));
}

fn u64_add(a: U64, b: U64) -> U64 {
  let lo_sum = a.lo + b.lo;
  let carry = u32(lo_sum < a.lo);
  return U64(a.hi + b.hi + carry, lo_sum);
}

fn u64_mul(a: U64, b: U64) -> U64 {
  let hi = u32_mul_hi(a.lo, b.lo);
  return U64(a.hi * b.lo + a.lo * b.hi + hi, a.lo * b.lo);
}

fn u64_sqr(a: U64) -> U64 {
  let hi = u32_mul_hi(a.lo, a.lo);
  return U64(2 * a.hi * a.lo + hi, a.lo * a.lo);
}

fn u64_swp(a: U64) -> U64 {
  return U64(a.lo, a.hi);
}

fn u32_mul_hi(a: u32, b: u32) -> u32 {
  let ah = a >> 16;
  let bh = b >> 16;
  let al = a & 0xffff;
  let bl = b & 0xffff;
  let albl = al * bl;
  let ahbl = ah * bl;
  let albh = al * bh;
  let sum = (ahbl & 0xffff) + (albh & 0xffff) + (albl >> 16);
  return ah * bh + (ahbl >> 16) + (albh >> 16) + (sum >> 16);
}

fn erf_inv(x: f32) -> f32 {
    let xc = clamp(x, -0.99999, 0.99999);
    var w = log((1.0 - xc) * (1.0 + xc));
    if w < 5.0 {
        w = w - 2.5;
        var p = 2.81022636e-08;
        p = 3.43273939e-07 + p * w;
        p = -3.5233877e-06 + p * w;
        p = -4.39150654e-06 + p * w;
        p = 0.00021858087 + p * w;
        p = -0.00125372503 + p * w;
        p = -0.00417768164 + p * w;
        p = 0.246640727 + p * w;
        p = 1.50140941 + p * w;
        return p * x;
    } else {
        w = sqrt(w) - 3.0;
        var p = -0.000200214257;
        p = 0.000100950558 + p * w;
        p = 0.00134934322 + p * w;
        p = -0.00367342844 + p * w;
        p = 0.00573950773 + p * w;
        p = -0.0076224613 + p * w;
        p = 0.00943887047 + p * w;
        p = 1.00167406 + p * w;
        p = 2.83297682 + p * w;
        return p * x;
    }
}

fn sample_technique(path_length: u32, r: f32) -> Technique {
    let camera = 1 + u32(r * f32(path_length)); // pinhole camera; at least one camera vertex
    let light = path_length - camera;
    return Technique(camera, light);
}

fn uniform_sample_sphere(u1: f32, u2: f32) -> vec3f {
    let z = 1.0 - 2.0 * u1;
    let r = sqrt(max(0.0, 1.0 - z * z));
    let phi = 2.0 * PI * u2;
    return vec3f(r * cos(phi), r * sin(phi), z);
}

fn cosine_sample_hemisphere(n: vec3f, u1: f32, u2: f32) -> vec3f {
    // Sample a unit disk in R^2
    let xy = concentric_sample_disk(u1, u2);

    // Compute an orthonormal basis relative to n as the "z" direction
    let b = orthonormal_basis(n);

    // Compute the coordinates in this new orthonormal basis relative to the normal vector nz
    let z = sqrt(max(0.0, 1.0 - xy.x * xy.x - xy.y * xy.y));

    // Done
    return b.u * xy.x + b.v * xy.y + b.w * z;
}

fn concentric_sample_disk(u1: f32, u2: f32) -> vec2f {
    // Map uniform random numbers to $[-1,1]^2$
    let u_offset_x = 2.0 * u1 - 1.0;
    let u_offset_y = 2.0 * u2 - 1.0;

    // Handle degeneracy at the origin
    if u_offset_x == 0.0 && u_offset_y == 0.0 {
        return vec2f(0.0, 0.0);
    }

    // Apply concentric mapping to point
    var r: f32;
    var theta: f32;
    if abs(u_offset_x) > abs(u_offset_y) {
        r = u_offset_x;
        theta = (PI / 4.0) * (u_offset_y / u_offset_x);
    } else {
        r = u_offset_y;
        theta = (PI / 2.0) - ((PI / 4.0) * (u_offset_x / u_offset_y));
    }

    // Done
    return vec2f(r * cos(theta), r * sin(theta));
}

fn is_zero(v: vec3f) -> bool {
    return v.x == 0.0 && v.y == 0.0 && v.z == 0.0;
}

fn orthonormal_basis(n: vec3f) -> Basis {
    let nz = normalize(n);
    let ey = vec3f(0.0, 1.0, 0.0);
    var nx = normalize(cross(ey, nz));
    var ny: vec3f;
    if is_zero(nx) {
        let ex = vec3f(1.0, 0.0, 0.0);
        ny = normalize(cross(nz, ex));
        nx = normalize(cross(ny, nz));
    } else {
        ny = normalize(cross(nz, nx));
    };
    return Basis(nx, ny, nz);
}

fn choose_u32(b: bool, u1: u32, u2: u32) -> u32 {
    return u32(b) * u1 + u32(!b) * u2;
}

fn choose_f32(b: bool, u1: f32, u2: f32) -> f32 {
    return f32(b) * u1 + f32(!b) * u2;
}

fn choose_vec3f(b: bool, v1: vec3f, v2: vec3f) -> vec3f {
    return f32(b) * v1 + f32(!b) * v2;
}

fn approx_eq_f32(a: f32, b: f32, tolerance: f32) -> bool {
    return abs(a - b) < tolerance;
}

fn approx_eq_vec3f(a: vec3f, b: vec3f, tolerance: f32) -> bool {
    return approx_eq_f32(a.x, b.x, tolerance) && approx_eq_f32(a.y, b.y, tolerance) && approx_eq_f32(a.z, b.z, tolerance);
}

fn same_hemisphere(n: vec3f, v1: vec3f, v2: vec3f) -> bool {
    return sign(dot(v1, n)) == sign(dot(v2, n));
}

fn abs_cos_theta(n: vec3f, v: vec3f) -> f32 {
    return abs(dot(normalize(n), normalize(v)));
}

fn geometry_term(direction: vec3f, normal1: vec3f, normal2: vec3f) -> f32 {
    let d2 = dot(direction, direction);
    let x = (dot(normal1, direction) * dot(normal2, direction)) / (d2 * d2);
    return abs(x);
}

fn direction_to_area(direction: vec3f, normal: vec3f) -> f32 {
    let d2 = dot(direction, direction);
    let x = dot(normal, direction) / (d2 * sqrt(d2));
    return abs(x);
}

fn luminance(v: vec3f) -> f32 {
    return v.r * 0.212671 + v.g * 0.715160 + v.b * 0.072169;
}

fn get_pixel_coordinates(ray: Ray) -> PixelCoordinates {
    let d = normalize(ray.origin - camera.origin);
    let screen_center = camera.w * camera.distance;
    let wd = dot(camera.w, d);
    if wd == 0.0 {
        return PixelCoordinates(0, 0, false);
    }
    let t = dot(camera.w, screen_center) / wd;
    if t <= 0.0 {
        return PixelCoordinates(0, 0, false);
    }
    let p = t * d - screen_center;
    let px = u32(dot(camera.u, p) + f32(PIXEL_WIDTH) * 0.5);
    let py = u32(-dot(camera.v, p) + f32(PIXEL_HEIGHT) * 0.5);
    if 0 <= px && px < PIXEL_WIDTH && 0 <= py && py < PIXEL_HEIGHT {
        return PixelCoordinates(px, py, true);
    }
    return PixelCoordinates(0, 0, false);
}

fn camera_importance(direction: vec3f) -> f32 {
    let c = dot(normalize(direction), camera.w);
    let a = f32(PIXEL_WIDTH) * f32(PIXEL_HEIGHT);
    let c4 = c * c * c * c;
    let d2 = camera.distance * camera.distance;
    return d2 / (a * c4);
}

fn camera_positional_pdf(p: vec3f) -> f32 {
    return 1.0;
}

fn camera_directional_pdf(direction: vec3f) -> f32 {
    let c = dot(normalize(direction), camera.w);
    let d = camera.distance / c;
    let d2 = d * d;
    let a = f32(PIXEL_WIDTH) * f32(PIXEL_HEIGHT);
    return d2 / (a * c);
}

fn sample_camera(r: vec2f) -> CameraSample {
    let x = r[0] * f32(PIXEL_WIDTH);
    let y = r[1] * f32(PIXEL_HEIGHT);
    let u = camera.u * (x - f32(PIXEL_WIDTH) / 2.0);
    let v = -camera.v * (y - f32(PIXEL_HEIGHT) / 2.0);
    let w = camera.w * camera.distance;
    let direction = normalize(u + v + w);
    let positional_pdf = camera_positional_pdf(camera.origin);
    let directional_pdf = camera_directional_pdf(direction);
    return CameraSample(camera.origin, direction, camera.w, positional_pdf, directional_pdf, u32(x), u32(y));
}

fn enqueue(global_path_index: u32, local_invocation_index: u32, queue_id: u32) {
    workgroup_queue_ballot[local_invocation_index] = queue_id;
    workgroup_global_path_index[local_invocation_index] = global_path_index;

    workgroupBarrier();

    if local_invocation_index >= QUEUE_COUNT {
        return;
    }

    var tally: u32 = 0;

    for (var i: u32 = 0; i < WORKGROUP_SIZE; i++) {
        let queue_index = workgroup_queue_ballot[i];
        tally = tally + u32(queue_index == local_invocation_index);
    }

    if tally == 0 {
        return;
    }

    var index = atomicAdd(&queue.count[local_invocation_index], tally);
    let last_index = index + tally - 1;

    for (var i: u32 = 0; i < WORKGROUP_SIZE; i++) {
        let queue_index = workgroup_queue_ballot[i];
        let id = workgroup_global_path_index[i];
        let index_match = queue_index == local_invocation_index;
        queue.index[local_invocation_index][index] = choose_u32(index_match, id, queue.index[local_invocation_index][index]);
        index = index + u32(index_match && index < last_index);
    }
}

fn contribute(contribution: vec3f, x: u32, y: u32) {
    atomicAdd(&image.pixels[y][x][0], u32(contribution.r * FIXED_POINT_SCALE));
    atomicAdd(&image.pixels[y][x][1], u32(contribution.g * FIXED_POINT_SCALE));
    atomicAdd(&image.pixels[y][x][2], u32(contribution.b * FIXED_POINT_SCALE));
}

fn read_image(x: u32, y: u32) -> vec3f {
    let r = atomicLoad(&image.pixels[y][x][0]);
    let g = atomicLoad(&image.pixels[y][x][1]);
    let b = atomicLoad(&image.pixels[y][x][2]);
    return vec3f(f32(r) / FIXED_POINT_SCALE, f32(g) / FIXED_POINT_SCALE, f32(b) / FIXED_POINT_SCALE);
}

fn get_chain_contribution(chain_id: u32) -> vec3f {
    return vec3f(chain.contribution[0][chain_id], chain.contribution[1][chain_id], chain.contribution[2][chain_id]);
}

fn set_chain_contribution(chain_id: u32, c: vec3f) {
    chain.contribution[0][chain_id] = c.r;
    chain.contribution[1][chain_id] = c.g;
    chain.contribution[2][chain_id] = c.b;
}

fn set_chain_large_step_index(chain_id: u32, index: U64) {
    chain.large_step_index[HI][chain_id] = index.hi;
    chain.large_step_index[LO][chain_id] = index.lo;
}

fn compute_large_step_index(chain_id: u32, i: u32) -> U64 {
    let iteration = chain.iteration[chain_id];
    let numbers_per_iteration = chain.numbers_per_iteration[chain_id];
    let path_offset = i * chain.numbers_per_path[chain_id];
    return u64_add(u64_mul(u64_from(iteration), u64_from(numbers_per_iteration)), u64_from(path_offset));
}

fn get_contribution_weight(chain_id: u32, a: f32, contribution_type: u32, step_type: u32) -> f32 {
    let path_length = chain_id + MIN_PATH_LENGTH;
    let pdf = chain.pdf[chain_id];
    let sc = chain.scalar_contribution[chain_id];
    let b = chain.b[chain_id];
    let step_term = f32(contribution_type == PROPOSAL && step_type == LARGE_STEP);
    return ((f32(path_length) / pdf) * (a + step_term)) / ((sc / b) + LARGE_STEP_PROBABILITY);
}

fn intersect_sphere(center: vec3f, radius: f32, ray: Ray) -> f32 {
    let c = center - ray.origin;
    let b = dot(c, ray.direction);
    var det = b * b - dot(c, c) + radius * radius;
    if det < 0.0 {
        return MAX_F32;
    }
    det = sqrt(det);
    let threshold = 1e-4;
    var t = b - det;
    if t <= threshold {
        t = b + det;
        if t <= threshold {
            return MAX_F32;
        }
    }
    return t;
}

fn intersect(ray: Ray) -> Intersection {
    var best_t: f32 = MAX_F32;
    var best_sphere_id: u32 = 0;

    for (var i: u32 = 0; i < SPHERE_COUNT; i++) {
        let center = get_sphere_center(i);
        let radius = sphere.radius[i];
        let t = intersect_sphere(center, radius, ray);
        best_sphere_id = choose_u32(t < best_t, i, best_sphere_id);
        best_t = min(t, best_t);
    }

    let point = ray.origin + ray.direction * best_t;
    let center = get_sphere_center(best_sphere_id);
    let normal = normalize(point - center);

    return Intersection(point, normal, best_sphere_id, best_t < MAX_F32);
}

fn get_sphere_center(id: u32) -> vec3f {
    return vec3f(sphere.center[0][id], sphere.center[1][id], sphere.center[2][id]);
}

fn get_sphere_color(id: u32) -> vec3f {
    return vec3f(sphere.color[0][id], sphere.color[1][id], sphere.color[2][id]);
}

fn get_sphere_area(id: u32) -> f32 {
    let r = sphere.radius[id];
    return 4.0 * PI * r * r;
}

fn sample_light(r: vec4f) -> LightSample {
    let center = get_sphere_center(LIGHT_SPHERE_ID);
    let point = center + uniform_sample_sphere(r[0], r[1]) * sphere.radius[LIGHT_SPHERE_ID];
    let normal = normalize(point - center);
    let direction = cosine_sample_hemisphere(normal, r[2], r[3]);
    let positional_pdf = 1.0 / get_sphere_area(LIGHT_SPHERE_ID);
    let directional_pdf = abs(dot(normalize(direction), normal)) / PI;
    return LightSample(point, direction, normal, positional_pdf, directional_pdf);
}

fn light_positional_pdf(radius: f32) -> f32 {
    return 1.0 / (4.0 * PI * radius * radius);
}

fn light_directional_pdf(d: vec3f, n: vec3f) -> f32 {
    return abs_cos_theta(d, n) / PI;
}

fn light_direction_valid(direction: vec3f, normal: vec3f) -> bool {
    return dot(normal, direction) > 0.0;
}

fn sample_material(material_id: u32, p: vec3f, wo: vec3f, n: vec3f, u: vec2f) -> MaterialSample {
    return sample_matte_material(material_id, wo, n, u);
}

fn evaluate_material(material_id: u32, wo: vec3f, n: vec3f, wi: vec3f) -> MaterialEvaluation {
    let pdf = matte_material_directional_pdf(wo, n, wi);
    let throughput = get_sphere_color(material_id) * matte_material_reflectance(wo, n, wi);
    let valid = same_hemisphere(n, wo, wi);
    return MaterialEvaluation(pdf, pdf, throughput, valid);
}

fn sample_matte_material(material_id: u32, _wo: vec3f, n: vec3f, u: vec2f) -> MaterialSample {
    let wi = cosine_sample_hemisphere(n, u[0], u[1]);
    let pdf = abs_cos_theta(n, wi) / PI;
    let throughput = get_sphere_color(material_id) / PI;
    return MaterialSample(wi, pdf, pdf, throughput, true);
}

fn matte_material_reflectance(wo: vec3f, n: vec3f, wi: vec3f) -> f32 {
    return 1.0 / PI;
}

fn matte_material_directional_pdf(wo: vec3f, n: vec3f, wi: vec3f) -> f32 {
    let h = f32(same_hemisphere(n, wo, wi)) ;
    return h * abs_cos_theta(n, wi) / PI;
}

fn set_ray_origin(i: u32, o: vec3f) {
    path.ray_origin[0][i] = o.x;
    path.ray_origin[1][i] = o.y;
    path.ray_origin[2][i] = o.z;
}

fn set_ray_direction(i: u32, d: vec3f) {
    path.ray_direction[0][i] = d.x;
    path.ray_direction[1][i] = d.y;
    path.ray_direction[2][i] = d.z;
}

fn set_technique(i: u32, t: Technique) {
    path.technique[CAMERA][i] = t.camera;
    path.technique[LIGHT][i] = t.light;
}

fn set_point(a: u32, b: u32, i: u32, p: vec3f) {
    path.point[a][b][0][i] = p.x;
    path.point[a][b][1][i] = p.y;
    path.point[a][b][2][i] = p.z;
}

fn get_point(t: u32, o: u32, i: u32) -> vec3f {
    return vec3f(path.point[t][o][0][i], path.point[t][o][1][i], path.point[t][o][2][i]);
}

fn get_normal(t: u32, o: u32, i: u32) -> vec3f {
    return vec3f(path.normal[t][o][0][i], path.normal[t][o][1][i], path.normal[t][o][2][i]);
}

fn set_normal(a: u32, b: u32, i: u32, p: vec3f) {
    path.normal[a][b][0][i] = p.x;
    path.normal[a][b][1][i] = p.y;
    path.normal[a][b][2][i] = p.z;
}

fn shift_point(path_type: u32, i: u32) {
    set_point(path_type, PENULTIMATE, i, get_point(path_type, ULTIMATE, i));
}

fn shift_normal(path_type: u32, i: u32) {
    set_normal(path_type, PENULTIMATE, i, get_normal(path_type, ULTIMATE, i));
}

fn get_ray_origin(i: u32) -> vec3f {
    return vec3f(path.ray_origin[0][i], path.ray_origin[1][i], path.ray_origin[2][i]);
}

fn get_ray_direction(i: u32) -> vec3f {
    return vec3f(path.ray_direction[0][i], path.ray_direction[1][i], path.ray_direction[2][i]);
}

fn get_ray(i: u32) -> Ray {
    return Ray(get_ray_origin(i), get_ray_direction(i));
}

fn get_technique(i: u32) -> Technique {
    return Technique(path.technique[CAMERA][i], path.technique[LIGHT][i]);
}

fn shift_pdf_fwd(path_type: u32, i: u32) {
    path.pdf_fwd[path_type][PENULTIMATE][i] = path.pdf_fwd[path_type][ULTIMATE][i];
}

fn update_beta(i: u32, beta: vec3f) {
    path.beta[0][i] *= beta.r;
    path.beta[1][i] *= beta.g;
    path.beta[2][i] *= beta.b;
}

fn set_beta(i: u32, beta: vec3f) {
    path.beta[0][i] = beta.r;
    path.beta[1][i] = beta.g;
    path.beta[2][i] = beta.b;
}

fn get_beta(i: u32) -> vec3f {
    return vec3f(path.beta[0][i], path.beta[1][i], path.beta[2][i]);
}

fn get_mis_weight(i: u32) -> f32 {
    let sum_ri = path.sum_inv_ri[CAMERA][i] * path.prod_ri[CAMERA][i] + path.prod_ri[CAMERA][i] - 1.0 
        + path.sum_inv_ri[LIGHT][i] * path.prod_ri[LIGHT][i] + path.prod_ri[LIGHT][i] - 1.0;
    return 1.0 / (1.0 + sum_ri);
}

fn get_path_contribution(i: u32) -> vec3f {
    return get_beta(i) * get_mis_weight(i);
}

fn binary_search(min_path_index: u32, max_path_index: u32, sum: f32, goal: f32) -> u32 {
    var l: u32 = min_path_index;
    var r: u32 = max_path_index;
    var m: u32 = 0;

    while l <= r {
        m = (l + r) / 2;
        if m == min_path_index {
            break;
        }
        let vr = path.cdf[m] / sum;
        if goal <= vr {
            let vl = path.cdf[m - 1] / sum;
            if goal > vl {
                break;
            } else {
                r = m - 1;
            }
        } else {
            l = m + 1;
        }
    }

    return m;
}

fn set_pixel(i: u32, x: u32, y: u32) {
    path.pixel[0][i] = x;
    path.pixel[1][i] = y;
}

fn get_pixel(i: u32) -> vec2u {
    return vec2u(path.pixel[0][i], path.pixel[1][i]);
}

fn log_vertex(path_type: u32, i: u32) {
    if PATH_LOG_ENABLED {
        if i == PATH_LOG_TARGET_INDEX {
            let point = get_point(path_type, ULTIMATE, i);
            let normal = get_normal(path_type, ULTIMATE, i);
            let direction = get_ray_direction(i);
            let sphere_id = path.material_id[path_type][i];
            let vertex_index = path.vertex_index[i];
            let technique = get_technique(i);
            var j: u32 = 0;
            if vertex_index < technique.camera {
                j = vertex_index;
            } else {
                j = (technique.camera + technique.light) - (vertex_index - technique.camera) - 1;
            }
            path_log.vertices[j] = VertexLog(point, normal, direction, sphere_id);
        }
    }
}

fn log_contribution(i: u32) {
    if PATH_LOG_ENABLED {
        if i == PATH_LOG_TARGET_INDEX {
            path_log.beta = get_beta(i);
            path_log.mis_weight = get_mis_weight(i);
        }
    }
}
`;

const INITIALIZE_CODE = `
${WGSL_LIB_CODE}

@group(UNIFORM_GROUP) @binding(UNIFORM_BINDING) var<uniform> uniforms: InitializeUniforms;

@compute
@workgroup_size(WORKGROUP_SIZE)
fn initialize(@builtin(global_invocation_id) id: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let i = id.x;

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if i < PATH_COUNT {
        // Set the context
        path.step_type[i] = LARGE_STEP;
        path.index[i] = i;
        path.length[i] = uniforms.path_length;
        path.vertex_index[i] = 0;
        path.cdf[i] = 0;
        path.prod_ri[CAMERA][i] = 1.0;
        path.prod_ri[LIGHT][i] = 1.0;
        path.sum_inv_ri[CAMERA][i] = 0.0;
        path.sum_inv_ri[LIGHT][i] = 0.0;

        // Set the queue
        queue_id = SAMPLE_CAMERA_QUEUE_ID;
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const SAMPLE_CAMERA_CODE = `
${WGSL_LIB_CODE}

@compute 
@workgroup_size(WORKGROUP_SIZE)
fn sample_camera_main(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[SAMPLE_CAMERA_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[SAMPLE_CAMERA_QUEUE_ID]) {
        // Determine technique
        let path_length = path.length[i];
        let technique = sample_technique(path_length, rand_1(i, TECHNIQUE_STREAM_INDEX));
        set_technique(i, technique);

        // Sample
        let sample = sample_camera(rand_2(i, CAMERA_STREAM_INDEX));

        // Set initial ray
        set_ray_origin(i, sample.point);
        set_ray_direction(i, sample.direction);

        // Set pixel coordinates
        set_pixel(i, sample.x, sample.y);

        // MIS
        path.pdf_fwd[CAMERA][ULTIMATE][i] = sample.positional_pdf;

        // PDF
        path.directional_pdf[i] = sample.directional_pdf;

        // Beta
        let importance = camera_importance(sample.direction);
        let beta = vec3f(1.0, 1.0, 1.0) * (choose_f32(technique.camera > 1, importance, 1.0) / sample.positional_pdf);
        set_beta(i, beta);

        // Geometry
        set_point(CAMERA, ULTIMATE, i, sample.point);
        set_normal(CAMERA, ULTIMATE, i, sample.normal);

        // Determine queue
        queue_id = choose_u32(technique.camera > 1, INTERSECT_QUEUE_ID, SAMPLE_LIGHT_QUEUE_ID);

        // Log
        log_vertex(CAMERA, i);
    }
    
    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const SAMPLE_LIGHT_CODE = `
${WGSL_LIB_CODE}

@compute 
@workgroup_size(WORKGROUP_SIZE)
fn sample_light_main(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[SAMPLE_LIGHT_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[SAMPLE_LIGHT_QUEUE_ID]) {
        // Update context
        path.vertex_index[i]++;

        // Sample        
        let sample = sample_light(rand_4(i, LIGHT_STREAM_INDEX));

        // Set initial ray
        set_ray_origin(i, sample.point);
        set_ray_direction(i, sample.direction);

        // MIS
        path.pdf_fwd[LIGHT][ULTIMATE][i] = sample.positional_pdf;

        // PDF
        path.directional_pdf[i] = sample.directional_pdf;

        // Beta
        let radiance = get_sphere_color(LIGHT_SPHERE_ID);
        let beta = radiance / sample.positional_pdf;
        update_beta(i, beta);

        // Geometry
        set_point(LIGHT, ULTIMATE, i, sample.point);
        set_normal(LIGHT, ULTIMATE, i, sample.normal);

        // Determine queue
        let technique = get_technique(i);
        queue_id = choose_u32(technique.light == 1, CONNECT_QUEUE_ID, INTERSECT_QUEUE_ID);

        // Log
        log_vertex(LIGHT, i);
    }
    
    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const CLEAR_QUEUE_CODE = `
${WGSL_LIB_CODE}

@group(UNIFORM_GROUP) @binding(UNIFORM_BINDING) var<uniform> uniforms: ClearQueueUniforms;

@compute
@workgroup_size(1)
fn clear_queue() {
    atomicStore(&queue.count[uniforms.queue_id], 0);
}
`;
const DISPATCH_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(1)
fn dispatch() {
    for (var queue_id: u32 = 0; queue_id < QUEUE_COUNT; queue_id++) {
        let count = atomicLoad(&queue.count[queue_id]);
        let workgroup_count = u32(ceil(f32(count) / f32(WORKGROUP_SIZE)));
        dispatch_indirect_parameters[queue_id] = vec3u(workgroup_count, 1, 1);
    }
}
`;
const INTERSECT_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn intersect_main(@builtin(global_invocation_id) id: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index: u32 = id.x;
    let i = queue.index[INTERSECT_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[INTERSECT_QUEUE_ID]) {
        // Context
        let path_length = path.length[i];
        let vertex_index = path.vertex_index[i] + 1;
        path.vertex_index[i] = vertex_index;
        let technique = get_technique(i);
        let path_type = choose_u32(vertex_index < technique.camera, CAMERA, LIGHT);

        // Intersect
        let ray = get_ray(i);
        let intersection = intersect(ray);
        let valid = intersection.valid && (
            (vertex_index < path_length - 1 && intersection.sphere_id != LIGHT_SPHERE_ID) || 
            (vertex_index == path_length - 1 && technique.light == 0 && intersection.sphere_id == LIGHT_SPHERE_ID) ||
            (vertex_index == path_length - 1 && technique.light > 0 && intersection.sphere_id != LIGHT_SPHERE_ID)
        );

        // MIS
        shift_pdf_fwd(path_type, i);
        let direction = intersection.point - get_point(path_type, ULTIMATE, i);
        let directional_pdf = path.directional_pdf[i];
        path.pdf_fwd[path_type][ULTIMATE][i] = directional_pdf * direction_to_area(direction, intersection.normal);

        // Beta
        let emission = choose_vec3f(intersection.sphere_id == LIGHT_SPHERE_ID, get_sphere_color(LIGHT_SPHERE_ID), vec3f(1.0, 1.0, 1.0));
        let beta = emission * abs_cos_theta(direction, get_normal(path_type, ULTIMATE, i)) / directional_pdf;
        update_beta(i, beta);

        // Material
        path.material_id[path_type][i] = intersection.sphere_id;

        // Geometry
        shift_point(path_type, i);
        shift_normal(path_type, i);
        set_point(path_type, ULTIMATE, i, intersection.point);
        set_normal(path_type, ULTIMATE, i, intersection.normal);

        // Determine queue
        queue_id = choose_u32(vertex_index + 1 < technique.camera || (vertex_index >= technique.camera && vertex_index + 1 < path_length), SAMPLE_MATERIAL_QUEUE_ID, queue_id);
        queue_id = choose_u32(vertex_index == path_length - 1 && technique.light > 0, CONNECT_QUEUE_ID, queue_id);
        queue_id = choose_u32(vertex_index == technique.camera - 1 && technique.light == 0, POST_CONNECT_NULL_QUEUE_ID, queue_id);
        queue_id = choose_u32(vertex_index == technique.camera - 1 && technique.light > 0, SAMPLE_LIGHT_QUEUE_ID, queue_id);
        queue_id = choose_u32(valid, queue_id, NULL_QUEUE_ID);

        log_vertex(path_type, i);
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const CONNECT_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn connect(@builtin(global_invocation_id) id: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index = id.x;
    let i = queue.index[CONNECT_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[CONNECT_QUEUE_ID]) {
        // Context
        let path_length = path.length[i];
        let technique = get_technique(i);

        // Intersect
        let source = get_point(CAMERA, ULTIMATE, i);
        let destination = get_point(LIGHT, ULTIMATE, i);
        let direction = normalize(destination - source);
        let ray = Ray(source, direction);
        let intersection = intersect(ray);

        // Validate
        let valid = intersection.valid && intersection.sphere_id == path.material_id[LIGHT][i];

        // Determine queue
        queue_id = choose_u32(technique.camera == 1, POST_CONNECT_CAMERA_DIRECT_QUEUE_ID, queue_id);
        queue_id = choose_u32(technique.camera > 1, POST_CONNECT_CAMERA_INDIRECT_QUEUE_ID, queue_id);
        queue_id = choose_u32(valid, queue_id, NULL_QUEUE_ID);
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const POST_CONNECT_NULL_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn post_connect_null_main(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[POST_CONNECT_NULL_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[POST_CONNECT_NULL_QUEUE_ID]) {
        // MIS
        let p1 = get_point(CAMERA, PENULTIMATE, i);
        let p2 = get_point(CAMERA, ULTIMATE, i);
        let n1 = get_normal(CAMERA, PENULTIMATE, i);
        let n2 = get_normal(CAMERA, ULTIMATE, i);
        let d1 = p2 - p1;
        let d2 = p1 - p2;

        let ri1 = light_directional_pdf(d2, n2) * direction_to_area(d2, n1) / path.pdf_fwd[CAMERA][PENULTIMATE][i];
        path.prod_ri[CAMERA][i] *= ri1;
        path.sum_inv_ri[CAMERA][i] += 1.0 / path.prod_ri[CAMERA][i];

        let radius = sphere.radius[LIGHT_SPHERE_ID];
        let ri2 = light_positional_pdf(radius) / path.pdf_fwd[CAMERA][ULTIMATE][i];
        path.prod_ri[CAMERA][i] *= ri2;
        path.sum_inv_ri[CAMERA][i] += 1.0 / path.prod_ri[CAMERA][i];

        // Next queue
        queue_id = CONTRIBUTE_QUEUE_ID;
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const POST_CONNECT_CAMERA_DIRECT_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn post_connect_camera_direct_main(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[POST_CONNECT_CAMERA_DIRECT_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[POST_CONNECT_CAMERA_DIRECT_QUEUE_ID]) {
        // Context
        let technique = get_technique(i);

        // Geometry
        let p1 = get_point(CAMERA, ULTIMATE, i);
        let p2 = get_point(LIGHT, ULTIMATE, i);
        let n1 = get_normal(CAMERA, ULTIMATE, i);
        let n2 = get_normal(LIGHT, ULTIMATE, i);
        let d1 = p2 - p1;

        // Beta
        let importance = camera_importance(d1);
        let beta = vec3f(1.0, 1.0, 1.0) * choose_f32(technique.camera == 1, importance, 1.0) * choose_f32(technique.light > 1, geometry_term(d1, n1, n2), 1.0);
        update_beta(i, beta);

        // MIS
        let ri = camera_directional_pdf(d1) * direction_to_area(d1, n2) / path.pdf_fwd[LIGHT][ULTIMATE][i];
        path.final_ri[i] = ri;

        // Pixel coordinates
        let pc = get_point(CAMERA, ULTIMATE, i);
        let pl = get_point(LIGHT, ULTIMATE, i);
        let d = pc - pl;
        let ray = Ray(pl, d);
        let pixel = get_pixel_coordinates(ray);
        set_pixel(i, pixel.x, pixel.y);

        // Next queue
        queue_id = choose_u32(technique.light > 1, POST_CONNECT_LIGHT_INDIRECT_QUEUE_ID, POST_CONNECT_LIGHT_DIRECT_QUEUE_ID);
        queue_id = choose_u32(pixel.valid, queue_id, NULL_QUEUE_ID);
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const POST_CONNECT_CAMERA_INDIRECT_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn post_connect_camera_indirect_main(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[POST_CONNECT_CAMERA_INDIRECT_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[POST_CONNECT_CAMERA_INDIRECT_QUEUE_ID]) {
        // Context
        let material_id = path.material_id[CAMERA][i];
        let technique = get_technique(i);

        // Compute geometry
        let p1 = get_point(CAMERA, PENULTIMATE, i);
        let p2 = get_point(CAMERA, ULTIMATE, i);
        let p3 = get_point(LIGHT, ULTIMATE, i);
        let n1 = get_normal(CAMERA, PENULTIMATE, i);
        let n2 = get_normal(CAMERA, ULTIMATE, i);
        let n3 = get_normal(LIGHT, ULTIMATE, i);
        let wo = p1 - p2;
        let wi = p3 - p2;

        // Evaluate material
        let evaluation = evaluate_material(material_id, wo, n2, wi);

        // Beta
        let g = choose_f32(technique.light > 1, geometry_term(wi, n2, n3), 1.0);
        let beta = evaluation.throughput * g;
        update_beta(i, beta);

        // MIS
        let ri1 = evaluation.pdf_rev * direction_to_area(wo, n2) / path.pdf_fwd[CAMERA][PENULTIMATE][i];
        path.prod_ri[CAMERA][i] *= ri1;
        path.sum_inv_ri[CAMERA][i] += 1.0 / path.prod_ri[CAMERA][i];

        let ri2 = evaluation.pdf_fwd * direction_to_area(wi, n3) / path.pdf_fwd[LIGHT][ULTIMATE][i];
        path.final_ri[i] = ri2;

        // Choose next queue
        queue_id = choose_u32(technique.light > 1, POST_CONNECT_LIGHT_INDIRECT_QUEUE_ID, POST_CONNECT_LIGHT_DIRECT_QUEUE_ID);
        queue_id = choose_u32(evaluation.valid, queue_id, NULL_QUEUE_ID);
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const POST_CONNECT_LIGHT_DIRECT_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn post_connect_light_direct_main(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[POST_CONNECT_LIGHT_DIRECT_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[POST_CONNECT_LIGHT_DIRECT_QUEUE_ID]) {
        // Geometry
        let p1 = get_point(CAMERA, ULTIMATE, i);
        let p2 = get_point(LIGHT, ULTIMATE, i);
        let n1 = get_normal(CAMERA, ULTIMATE, i);
        let n2 = get_normal(LIGHT, ULTIMATE, i);
        let d1 = p2 - p1;
        let d2 = p1 - p2;

        // Validation
        let valid = light_direction_valid(d2, n2);

        // Beta
        let beta = vec3f(1.0, 1.0, 1.0) * geometry_term(d1, n1, n2);
        update_beta(i, beta);

        // MIS
        let ri = light_directional_pdf(d2, n2) * direction_to_area(d2, n1) / path.pdf_fwd[CAMERA][ULTIMATE][i];
        path.prod_ri[CAMERA][i] *= ri;
        path.sum_inv_ri[CAMERA][i] += 1.0 / path.prod_ri[CAMERA][i];

        path.prod_ri[LIGHT][i] *= path.final_ri[i];
        path.sum_inv_ri[LIGHT][i] += 1.0 / path.prod_ri[LIGHT][i];

        // Next queue
        queue_id = choose_u32(valid, CONTRIBUTE_QUEUE_ID, NULL_QUEUE_ID);
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const POST_CONNECT_LIGHT_INDIRECT_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn post_connect_light_indirect_main(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[POST_CONNECT_LIGHT_INDIRECT_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[POST_CONNECT_LIGHT_INDIRECT_QUEUE_ID]) {
        // Context
        let material_id = path.material_id[LIGHT][i];
        let technique = get_technique(i);

        // Compute geometry
        let p1 = get_point(CAMERA, ULTIMATE, i);
        let p2 = get_point(LIGHT, ULTIMATE, i);
        let p3 = get_point(LIGHT, PENULTIMATE, i);
        let n1 = get_normal(CAMERA, ULTIMATE, i);
        let n2 = get_normal(LIGHT, ULTIMATE, i);
        let n3 = get_normal(LIGHT, PENULTIMATE, i);
        let wo = p1 - p2;
        let wi = p3 - p2;

        // Evaluate material
        let evaluation = evaluate_material(material_id, wo, n2, wi);

        // Beta
        let beta = evaluation.throughput;
        update_beta(i, beta);

        // MIS
        let ri1 = evaluation.pdf_fwd * direction_to_area(wo, n1) / path.pdf_fwd[CAMERA][ULTIMATE][i];
        path.prod_ri[CAMERA][i] *= ri1;
        path.sum_inv_ri[CAMERA][i] += 1.0 / path.prod_ri[CAMERA][i];

        let ri2 = evaluation.pdf_rev * direction_to_area(wi, n3) / path.pdf_fwd[LIGHT][PENULTIMATE][i];
        path.prod_ri[LIGHT][i] *= ri2;
        path.sum_inv_ri[LIGHT][i] += 1.0 / path.prod_ri[LIGHT][i];

        path.prod_ri[LIGHT][i] *= path.final_ri[i];
        path.sum_inv_ri[LIGHT][i] += 1.0 / path.prod_ri[LIGHT][i];

        // Choose next queue
        queue_id = choose_u32(evaluation.valid, CONTRIBUTE_QUEUE_ID, NULL_QUEUE_ID);
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const CONTRIBUTE_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn contribute_main(@builtin(global_invocation_id) gid: vec3u) {
    // Determine the global path index (i)
    let global_invocation_index = gid.x;
    let i = queue.index[CONTRIBUTE_QUEUE_ID][global_invocation_index];

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[CONTRIBUTE_QUEUE_ID]) {
        // Context
        let chain_id = path.length[i] - MIN_PATH_LENGTH;

        let pixel = get_pixel(i);

        // Compute the final contribution
        let c = get_path_contribution(i);
        let sc = luminance(c);
        path.cdf[i] = sc;

        // Compute the weight
        let a = min(1.0, sc / chain.scalar_contribution[chain_id]) / f32(chain.path_count[chain_id]);
        let weight = get_contribution_weight(chain_id, a, PROPOSAL, path.step_type[i]);

        // Contribute
        contribute(c * weight, pixel.x, pixel.y);

        // Log
        log_contribution(i);
    }
}
`;
const SAMPLE_MATERIAL_CODE = `
${WGSL_LIB_CODE}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn sample_material_main(@builtin(global_invocation_id) id: vec3u, @builtin(local_invocation_index) lid: u32) {
    // Determine the global path index (i)
    let global_invocation_index = id.x;
    let i = queue.index[SAMPLE_MATERIAL_QUEUE_ID][global_invocation_index];

    // Default to no queue
    var queue_id: u32 = NULL_QUEUE_ID;

    // Check bounds
    if global_invocation_index < atomicLoad(&queue.count[SAMPLE_MATERIAL_QUEUE_ID]) {
        // Context
        let vertex_index = path.vertex_index[i];
        let technique = get_technique(i);
        let stream_index = choose_u32(vertex_index < technique.camera, CAMERA_STREAM_INDEX, LIGHT_STREAM_INDEX);
        let path_type = choose_u32(vertex_index < technique.camera, CAMERA, LIGHT);

        // Sample
        let n1 = get_normal(path_type, PENULTIMATE, i);
        let n2 = get_normal(path_type, ULTIMATE, i);
        let p1 = get_point(path_type, PENULTIMATE, i);
        let p2 = get_point(path_type, ULTIMATE, i);
        let wo = p1 - p2;
        let sample = sample_material(path.material_id[path_type][i], p2, wo, n2, rand_2(i, stream_index));

        // Update ray
        set_ray_origin(i, p2);
        set_ray_direction(i, sample.wi);

        // MIS
        let ri = sample.pdf_rev * direction_to_area(wo, n1) / path.pdf_fwd[path_type][PENULTIMATE][i];
        path.prod_ri[path_type][i] *= ri;
        path.sum_inv_ri[path_type][i] += 1.0 / path.prod_ri[path_type][i];

        // PDF
        path.directional_pdf[i] = sample.pdf_fwd;

        // Beta
        let beta = sample.throughput;
        update_beta(i, beta);

        // Determine queue
        queue_id = choose_u32(sample.valid, INTERSECT_QUEUE_ID, queue_id);
    }

    // Enqueue
    enqueue(i, lid, queue_id);
}
`;
const BUILD_CDF_CODE = `
${WGSL_LIB_CODE}

@group(UNIFORM_GROUP) @binding(UNIFORM_BINDING) var<uniform> uniforms: BuildCdfUniforms;

@compute
@workgroup_size(WORKGROUP_SIZE)
fn build_cdf(@builtin(global_invocation_id) id: vec3u) {
    // Determine the global invocation index
    let global_invocation_index = id.x;

    // Check bounds
    if global_invocation_index >= chain.path_count[uniforms.chain_id] {
        return;
    }

    // Compute index parameters
    let two_pow_i: u32 = u32(1) << uniforms.iteration;
    let m = u32(global_invocation_index >= two_pow_i);
    let j = chain.min_path_index[uniforms.chain_id] + global_invocation_index;
    
    // Update prefix sums
    path.cdf[j] = path.cdf[j] + f32(m) * path.cdf[j - m * two_pow_i];
}
`;
const START_CHAIN_CODE = `
${WGSL_LIB_CODE}

@group(UNIFORM_GROUP) @binding(UNIFORM_BINDING) var<uniform> uniforms: StartChainUniforms;

@compute
@workgroup_size(1)
fn start_chain() {
    let sum = path.cdf[PATH_COUNT - 1];
    let m = binary_search(0, PATH_COUNT - 1, sum, uniforms.random);
    let large_step_index = m * chain.numbers_per_path[uniforms.chain_id];
    chain.large_step_index[HI][uniforms.chain_id] = 0;
    chain.large_step_index[LO][uniforms.chain_id] = large_step_index;
    chain.small_step_count[uniforms.chain_id] = 1;
    chain.b[uniforms.chain_id] = sum;
    chain.iteration[uniforms.chain_id] += 1;
}
`;

class CameraData {
    #config;
    #scene;

    buffer;

    constructor(params) {
        this.#config = params.config;
        this.#scene = params.scene;
    }

    initialize(params) {
        const array = new ArrayBuffer(64);
        const view = this.getView({ array });
        const direction = VectorMath.sub(this.#scene.camera.lookAt, this.#scene.camera.origin);
        const distance = this.#config.image.height / (2.0 * Math.tan((this.#scene.camera.fieldOfView * Math.PI / 180.0) / 2.0));
        const basis = VectorMath.orthonormalBasis(direction);
        view.u.set([basis.u.x, basis.u.y, basis.u.z]);
        view.v.set([basis.v.x, basis.v.y, basis.v.z]);
        view.w.set([basis.w.x, basis.w.y, basis.w.z]);
        view.origin.set([this.#scene.camera.origin.x, this.#scene.camera.origin.y, this.#scene.camera.origin.z]);
        view.distance.set([distance]);
        this.buffer = params.device.createBuffer({
            label: 'camera buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
        params.device.queue.writeBuffer(this.buffer, 0, array);
    }

    getView(params) {
        return {
            u: new Float32Array(params.array, 0, 3),
            v: new Float32Array(params.array, 16, 3),
            w: new Float32Array(params.array, 32, 3),
            origin: new Float32Array(params.array, 48, 3),
            distance: new Float32Array(params.array, 60, 1),
        };
    }
}

class ChainData {
    #config;

    buffer;

    constructor(params) {
        this.#config = params.config;
    }

    initialize(params) {
        const count = this.#config.path.length.max - 1;
        const array = new ArrayBuffer(76 * count);
    
        const view = this.getView({ array });
    
        for (let i = 0; i < count; i++) {
            const key = KeyUtil.parse(KEYS[i]);
            view.key[0].set([key.hi], i);
            view.key[1].set([key.lo], i);
            view.iteration.set([0], i);
            const vertexCount = i + 2;
            const numbersPerStream = vertexCount * this.#config.random.counts.vertex;
            const numbersPerPath = 2 * numbersPerStream + 1;
            const numbersPerIteration = numbersPerPath * this.#config.path.count;
            view.numbers_per_iteration.set([numbersPerIteration], i);
            view.numbers_per_path.set([numbersPerPath], i);
            view.numbers_per_stream.set([numbersPerStream], i);
            view.large_step_index[0].set([0], i);
            view.large_step_index[1].set([0], i);
            view.min_path_index.set([0], i);
            view.path_count.set([this.#config.path.count], i);
        }

        this.buffer = params.device.createBuffer({
            label: 'chain buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
    
        params.device.queue.writeBuffer(this.buffer, 0, array);
    }

    getView(params) {
        const count = this.#config.path.length.max - 1;
        return {
            key: [
                new Uint32Array(params.array, 0, count),
                new Uint32Array(params.array, 4 * count, count),
            ],
            iteration: new Uint32Array(params.array, 8 * count, count),
            numbers_per_iteration: new Uint32Array(params.array, 12 * count, count),
            numbers_per_path: new Uint32Array(params.array, 16 * count, count),
            numbers_per_stream: new Uint32Array(params.array, 20 * count, count),
            large_step_index: [
                new Uint32Array(params.array, 24 * count, count),
                new Uint32Array(params.array, 28 * count, count),
            ],
            small_step_count: new Uint32Array(params.array, 32 * count, count),
            b: new Float32Array(params.array, 36 * count, count),
            pdf: new Float32Array(params.array, 40 * count, count),
            min_small_step_index: new Uint32Array(params.array, 44 * count, count),
            max_small_step_index: new Uint32Array(params.array, 48 * count, count),
            contribution: [
                new Float32Array(params.array, 52 * count, count),
                new Float32Array(params.array, 56 * count, count),
                new Float32Array(params.array, 60 * count, count),
            ],
            scalar_contribution: new Float32Array(params.array, 64 * count, count),
            min_path_index: new Uint32Array(params.array, 68 * count, count),
            path_count: new Uint32Array(params.array, 72 * count, count),
        };
    }
}

class DispatchIndirectParametersData {
    #config;

    buffer;

    constructor(params) {
        this.#config = params.config;
    }

    initialize(params) {
        const array = new Uint32Array(Array(4 * this.#config.queue.count).fill(0));

        this.buffer = params.device.createBuffer({
            label: 'dispatch indirect parameters buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC,
        });

        params.device.queue.writeBuffer(this.buffer, 0, array);
    }

    getView(params) {
        return new Uint32Array(params.array, 0, 4 * this.#config.queue.count);
    }
}

class ImageData {
    #config;

    buffer;

    constructor(params) {
        this.#config = params.config;
    }

    initialize(params) {
        const count = this.#config.image.width * this.#config.image.height;
        this.buffer = params.device.createBuffer({
            label: 'image buffer',
            size: 12 * count,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        });
    }

    getView(params) {
        const count = this.#config.image.width * this.#config.image.height;
        return {
            pixels: [
                [
                    new Uint32Array(params.array, 0, count),
                ],
                [
                    new Uint32Array(params.array, 4 * count, count),
                ],
                [
                    new Uint32Array(params.array, 8 * count, count),
                ],
            ],
        };
    }
}

class PathData {
    #config;

    buffer;

    constructor(params) {
        this.#config = params.config;
    }

    initialize(params) {
        const count = this.#config.path.count;
        this.buffer = params.device.createBuffer({
            label: 'path state buffer',
            size: 216 * count,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
    }

    getView(params) {
        const count = this.#config.path.count;
        return {
            step_type: new Uint32Array(params.array, 0, count),
            index: new Uint32Array(params.array, 4 * count, count),
            length: new Uint32Array(params.array, 8 * count, count),
            vertex_index: new Uint32Array(params.array, 12 * count, count),
            technique: [
                new Uint32Array(params.array, 16 * count, count),
                new Uint32Array(params.array, 20 * count, count),
            ],
            ray_origin: [
                new Float32Array(params.array, 24 * count, count),
                new Float32Array(params.array, 28 * count, count),
                new Float32Array(params.array, 32 * count, count),
            ],
            ray_direction: [
                new Float32Array(params.array, 36 * count, count),
                new Float32Array(params.array, 40 * count, count),
                new Float32Array(params.array, 44 * count, count),
            ],
            beta: [
                new Float32Array(params.array, 48 * count, count),
                new Float32Array(params.array, 52 * count, count),
                new Float32Array(params.array, 56 * count, count),
            ],
            pixel: [
                new Uint32Array(params.array, 60 * count, count),
                new Uint32Array(params.array, 64 * count, count),
            ],
            cdf: new Float32Array(params.array, 68 * count, count),
            point: [
                [
                    [
                        new Float32Array(params.array, 72 * count, count),
                        new Float32Array(params.array, 76 * count, count),
                        new Float32Array(params.array, 80 * count, count),
                    ],
                    [
                        new Float32Array(params.array, 84 * count, count),
                        new Float32Array(params.array, 88 * count, count),
                        new Float32Array(params.array, 92 * count, count),
                    ],
                ],
                [
                    [
                        new Float32Array(params.array, 96 * count, count),
                        new Float32Array(params.array, 100 * count, count),
                        new Float32Array(params.array, 104 * count, count),
                    ],
                    [
                        new Float32Array(params.array, 108 * count, count),
                        new Float32Array(params.array, 112 * count, count),
                        new Float32Array(params.array, 116 * count, count),
                    ],
                ],
            ],
            normal: [
                [
                    [
                        new Float32Array(params.array, 120 * count, count),
                        new Float32Array(params.array, 124 * count, count),
                        new Float32Array(params.array, 128 * count, count),
                    ],
                    [
                        new Float32Array(params.array, 132 * count, count),
                        new Float32Array(params.array, 136 * count, count),
                        new Float32Array(params.array, 140 * count, count),
                    ],
                ],
                [
                    [
                        new Float32Array(params.array, 144 * count, count),
                        new Float32Array(params.array, 148 * count, count),
                        new Float32Array(params.array, 152 * count, count),
                    ],
                    [
                        new Float32Array(params.array, 156 * count, count),
                        new Float32Array(params.array, 160 * count, count),
                        new Float32Array(params.array, 164 * count, count),
                    ],
                ],
            ],
            material_id: [
                new Uint32Array(params.array, 168 * count, count),
                new Uint32Array(params.array, 172 * count, count),
            ],
            pdf_fwd: [
                [
                    new Float32Array(params.array, 176 * count, count),
                    new Float32Array(params.array, 180 * count, count),
                ],
                [
                    new Float32Array(params.array, 184 * count, count),
                    new Float32Array(params.array, 188 * count, count),
                ],
            ],
            sum_inv_ri: [
                new Float32Array(params.array, 192 * count, count),
                new Float32Array(params.array, 196 * count, count),
            ],
            prod_ri: [
                new Float32Array(params.array, 200 * count, count),
                new Float32Array(params.array, 204 * count, count),
            ],
            directional_pdf: new Float32Array(params.array, 208 * count, count),
            final_ri: new Float32Array(params.array, 212 * count, count),
        };
    }
}

class QueueData {
    #config;

    buffer;

    constructor(params) {
        this.#config = params.config;
    }

    initialize(params) {
        this.buffer = params.device.createBuffer({
            label: 'queue buffer',
            size: 44 * this.#config.path.count + 4 * this.#config.queue.count,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
    }

    getView(params) {
        return {
            index: [
              new Uint32Array(params.array, 0, this.#config.path.count),
              new Uint32Array(params.array, 4 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 8 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 12 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 16 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 20 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 24 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 28 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 32 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 36 * this.#config.path.count, this.#config.path.count),
              new Uint32Array(params.array, 40 * this.#config.path.count, this.#config.path.count),
            ],
            count: new Uint32Array(params.array, 44 * this.#config.path.count, this.#config.queue.count),
          };
    }
}

class SceneData {
    #scene;

    buffer;

    constructor(params) {
        this.#scene = params.scene;
    }

    initialize(params) {
        const array = new ArrayBuffer(28 * this.#scene.spheres.length);

        const view = this.getView({ array });
    
        for (let i = 0; i < this.#scene.spheres.length; i++) {
            const sphere = this.#scene.spheres[i];
            view.radius.set([sphere.radius], i);
            view.center[0].set([sphere.center.x], i);
            view.center[1].set([sphere.center.y], i);
            view.center[2].set([sphere.center.z], i);
            view.color[0].set([sphere.color.r], i);
            view.color[1].set([sphere.color.g], i);
            view.color[2].set([sphere.color.b], i);
        }

        this.buffer = params.device.createBuffer({
            label: 'sphere buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
    
        params.device.queue.writeBuffer(this.buffer, 0, array);
    }

    getView(params) {
        return {
            radius: new Float32Array(params.array, 0, this.#scene.spheres.length),
            center: [
                new Float32Array(params.array, 4 * this.#scene.spheres.length, this.#scene.spheres.length),
                new Float32Array(params.array, 8 * this.#scene.spheres.length, this.#scene.spheres.length),
                new Float32Array(params.array, 12 * this.#scene.spheres.length, this.#scene.spheres.length),
            ],
            color: [
                new Float32Array(params.array, 16 * this.#scene.spheres.length, this.#scene.spheres.length),
                new Float32Array(params.array, 20 * this.#scene.spheres.length, this.#scene.spheres.length),
                new Float32Array(params.array, 24 * this.#scene.spheres.length, this.#scene.spheres.length),
            ],
        };
    }
}

class PathLogData {
    #config;

    buffer;

    constructor(params) {
        this.#config = params.config;
    }

    initialize(params) {
        const count = this.#config.path.length.max;
        const array = new ArrayBuffer(48 * count + 20 + 12);

        this.buffer = params.device.createBuffer({
            label: 'path_log buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
    
        params.device.queue.writeBuffer(this.buffer, 0, array);
    }

    getView(params) {
        const count = this.#config.path.length.max;
        
        const view = {
            vertices: [],
            beta: new Float32Array(params.array, 48 * count, 3),
            mis_weight: new Float32Array(params.array, 48 * count + 12, 1),
            foo: new Float32Array(params.array, 48 * count + 16, 1),
        };

        for (let i = 0; i < count; i++) {
            view.vertices.push({
                point: new Float32Array(params.array, 48 * i, 3),
                normal: new Float32Array(params.array, 48 * i + 16, 3),
                direction: new Float32Array(params.array, 48 * i + 32, 3),
                sphere_id: new Uint32Array(params.array, 48 * i + 44, 1),
            });
        }

        return view;
    }
}

class InitializeKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'initialize module',
            code: INITIALIZE_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'initialize compute pipeline',
            layout: this.#data.pipelineLayout.uniform,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        const array = new ArrayBuffer(4);
        const view = {
            path_length: new Uint32Array(array, 0, 1),
        };
        view.path_length.set([params.pathLength]);
    
        const buffer = params.device.createBuffer({
            label: 'uniforms buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
    
        params.device.queue.writeBuffer(buffer, 0, array);
    
        const bindGroup = params.device.createBindGroup({
            label: 'initialize uniforms bind group',
            layout: this.#data.bindGroupLayout.uniform,
            entries: [
                {
                    binding: this.#config.bindGroup.uniform.binding.parameters,
                    resource: {
                        buffer,
                    },
                },
            ],
        });

        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.setBindGroup(this.#config.bindGroup.auxiliary.index, this.#data.bindGroup.auxiliary);
        params.pass.setBindGroup(this.#config.bindGroup.uniform.index, bindGroup);
        params.pass.dispatchWorkgroups(Math.ceil(this.#config.path.count / this.#config.workgroup.size));
    }
}

class SampleCameraKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'sample camera module',
            code: SAMPLE_CAMERA_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'sample camera compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.sample.camera);
    }
}

class SampleLightKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'sample light module',
            code: SAMPLE_LIGHT_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'sample light compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(0, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.sample.light);
    }
}

class ClearQueueKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'clear_queue module',
            code: CLEAR_QUEUE_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'clear_queue compute pipeline',
            layout: this.#data.pipelineLayout.uniform,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        const array = new ArrayBuffer(4);
        const view = {
            queue_id: new Uint32Array(array, 0, 1),
        };
        view.queue_id.set([params.queueId]);
    
        const buffer = params.device.createBuffer({
            label: 'clear_queue uniforms buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
    
        params.device.queue.writeBuffer(buffer, 0, array);
    
        const bindGroup = params.device.createBindGroup({
            label: 'clear_queue uniforms bind group',
            layout: this.#data.bindGroupLayout.uniform,
            entries: [
                {
                    binding: this.#config.bindGroup.uniform.binding.parameters,
                    resource: {
                        buffer,
                    },
                },
            ],
        });

        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.setBindGroup(this.#config.bindGroup.auxiliary.index, this.#data.bindGroup.auxiliary);
        params.pass.setBindGroup(this.#config.bindGroup.uniform.index, bindGroup);
        params.pass.dispatchWorkgroups(1);
    }
}

class DispatchKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'dispatch module',
            code: DISPATCH_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'dispatch compute pipeline',
            layout: this.#data.pipelineLayout.auxiliary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.setBindGroup(this.#config.bindGroup.auxiliary.index, this.#data.bindGroup.auxiliary);
        params.pass.dispatchWorkgroups(1);
    }
}

class IntersectKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'intersect module',
            code: INTERSECT_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'intersect compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(0, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.intersect);
    }
}

class ConnectKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'connect module',
            code: CONNECT_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'connect compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(0, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.connect);
    }
}

class PostConnectNullKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'post-connect null module',
            code: POST_CONNECT_NULL_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'post-connect null compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.postConnect.null);
    }
}

class PostConnectCameraDirectKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'post-connect camera direct module',
            code: POST_CONNECT_CAMERA_DIRECT_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'post-connect camera direct compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.postConnect.camera.direct);
    }
}

class PostConnectCameraIndirectKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'post-connect camera indirect module',
            code: POST_CONNECT_CAMERA_INDIRECT_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'post-connect camera indirect compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.postConnect.camera.indirect);
    }
}

class PostConnectLightDirectKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'post-connect light direct module',
            code: POST_CONNECT_LIGHT_DIRECT_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'post-connect light direct compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.postConnect.light.direct);
    }
}

class PostConnectLightIndirectKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'post-connect light indirect module',
            code: POST_CONNECT_LIGHT_INDIRECT_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'post-connect light indirect compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.postConnect.light.indirect);
    }
}

class ContributeKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'contribute module',
            code: CONTRIBUTE_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'contribute compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(0, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.contribute);
    }
}

class SampleMaterialKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'sample material module',
            code: SAMPLE_MATERIAL_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'sample material compute pipeline',
            layout: this.#data.pipelineLayout.primary,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.dispatchWorkgroupsIndirect(this.#data.element.dispatchIndirectParameters.buffer, 16 * this.#config.queue.index.sample.material);
    }
}

class BuildCdfKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'build_cdf module',
            code: BUILD_CDF_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'build_cdf compute pipeline',
            layout: this.#data.pipelineLayout.uniform,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        const iterations = Math.ceil(Math.log2(this.#config.path.count));
        for (var iteration = 0; iteration < iterations; iteration++) {
            const array = new ArrayBuffer(8);
            const view = {
                chain_id: new Uint32Array(array, 0, 1),
                iteration: new Uint32Array(array, 4, 1),
            };
            view.chain_id.set([params.chainId]);
            view.iteration.set([iteration]);
        
            const buffer = params.device.createBuffer({
                label: 'build_cdf uniforms buffer',
                size: array.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
        
            params.device.queue.writeBuffer(buffer, 0, array);
        
            const bindGroup = params.device.createBindGroup({
                label: 'build_cdf uniforms bind group',
                layout: this.#data.bindGroupLayout.uniform,
                entries: [
                    {
                        binding: this.#config.bindGroup.uniform.binding.parameters,
                        resource: {
                            buffer,
                        },
                    },
                ],
            });

            params.pass.setPipeline(this.#pipeline);
            params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
            params.pass.setBindGroup(this.#config.bindGroup.auxiliary.index, this.#data.bindGroup.auxiliary);
            params.pass.setBindGroup(this.#config.bindGroup.uniform.index, bindGroup);
            params.pass.dispatchWorkgroups(Math.ceil(this.#config.path.count / this.#config.workgroup.size));
        }
    }
}

class StartChainKernel {
    #config;
    #data;
    #pipeline;

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;
    }

    initialize(params) {
        const module = params.device.createShaderModule({
            label: 'start_chain module',
            code: START_CHAIN_CODE,
        });

        this.#pipeline = params.device.createComputePipeline({
            label: 'start_chain compute pipeline',
            layout: this.#data.pipelineLayout.uniform,
            compute: {
                module,
            }
        });
    }

    encode(params) {
        const array = new ArrayBuffer(8);
        const view = {
            chain_id: new Uint32Array(array, 0, 1),
            random: new Float32Array(array, 4, 1),
        };
        view.chain_id.set([params.chainId]);
        view.random.set([params.random]);
    
        const buffer = params.device.createBuffer({
            label: 'start_chain uniforms buffer',
            size: array.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
    
        params.device.queue.writeBuffer(buffer, 0, array);
    
        const bindGroup = params.device.createBindGroup({
            label: 'start_chain uniforms bind group',
            layout: this.#data.bindGroupLayout.uniform,
            entries: [
                {
                    binding: this.#config.bindGroup.uniform.binding.parameters,
                    resource: {
                        buffer,
                    },
                },
            ],
        });

        params.pass.setPipeline(this.#pipeline);
        params.pass.setBindGroup(this.#config.bindGroup.primary.index, this.#data.bindGroup.primary);
        params.pass.setBindGroup(this.#config.bindGroup.auxiliary.index, this.#data.bindGroup.auxiliary);
        params.pass.setBindGroup(this.#config.bindGroup.uniform.index, bindGroup);
        params.pass.dispatchWorkgroups(1);
    }
}

class Data {
    #config;
    #scene;

    bindGroup = {
        primary: {},
        auxiliary: {},
        uniform: {},
    };

    element = {};

    bindGroupLayout = {};

    pipelineLayout = {};

    constructor(params) {
        this.#config = params.config;
        this.#scene = params.scene;
    }

    initialize(params) {
        // Bind group layouts
        this.bindGroupLayout.primary = params.device.createBindGroupLayout({
            label: 'primary bind group layout',
            entries: [
                {
                    binding: this.#config.bindGroup.primary.binding.camera,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'read-only-storage',
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.sphere,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'read-only-storage',
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.chain,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'storage',
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.path,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'storage',
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.image,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'storage',
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.queue,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'storage',
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.pathLog,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'storage',
                    },
                },
            ],
        });

        this.bindGroupLayout.auxiliary = params.device.createBindGroupLayout({
            label: 'auxiliary bind group layout',
            entries: [
                {
                    binding: this.#config.bindGroup.auxiliary.binding.dispatchIndirectParameters,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'storage',
                    },
                },
            ],
        });

        this.bindGroupLayout.uniform = params.device.createBindGroupLayout({
            label: 'uniform bind group layout',
            entries: [
                {
                    binding: this.#config.bindGroup.uniform.binding.parameters,
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {
                        type: 'uniform',
                    },
                },
            ],
        });

        // Pipeline layouts
        this.pipelineLayout.primary = params.device.createPipelineLayout({
            bindGroupLayouts: [
                this.bindGroupLayout.primary,
            ],
        });
    
        this.pipelineLayout.auxiliary = params.device.createPipelineLayout({
            bindGroupLayouts: [
                this.bindGroupLayout.primary,
                this.bindGroupLayout.auxiliary,
            ],
        });
    
        this.pipelineLayout.uniform = params.device.createPipelineLayout({
            bindGroupLayouts: [
                this.bindGroupLayout.primary,
                this.bindGroupLayout.auxiliary,
                this.bindGroupLayout.uniform,
            ],
        });

        // Buffers
        this.element.camera = new CameraData({ config: this.#config, scene: this.#scene });
        this.element.camera.initialize({ device: params.device });
        this.element.sphere = new SceneData({ scene: this.#scene });
        this.element.sphere.initialize({ device: params.device });
        this.element.chain = new ChainData({ config: this.#config });
        this.element.chain.initialize({ device: params.device });
        this.element.path = new PathData({ config: this.#config });
        this.element.path.initialize({ device: params.device });
        this.element.image = new ImageData({ config: this.#config });
        this.element.image.initialize({ device: params.device });
        this.element.queue = new QueueData({ config: this.#config });
        this.element.queue.initialize({ device: params.device });
        this.element.pathLog = new PathLogData({ config: this.#config });
        this.element.pathLog.initialize({ device: params.device });
        this.element.dispatchIndirectParameters = new DispatchIndirectParametersData({ config: this.#config });
        this.element.dispatchIndirectParameters.initialize({ device: params.device });

        // Bind groups
        this.bindGroup.primary = params.device.createBindGroup({
            label: 'primary bind group',
            layout: this.bindGroupLayout.primary,
            entries: [
                {
                    binding: this.#config.bindGroup.primary.binding.camera,
                    resource: {
                        buffer: this.element.camera.buffer,
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.sphere,
                    resource: {
                        buffer: this.element.sphere.buffer,
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.chain,
                    resource: {
                        buffer: this.element.chain.buffer,
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.path,
                    resource: {
                        buffer: this.element.path.buffer,
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.image,
                    resource: {
                        buffer: this.element.image.buffer,
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.queue,
                    resource: {
                        buffer: this.element.queue.buffer,
                    },
                },
                {
                    binding: this.#config.bindGroup.primary.binding.pathLog,
                    resource: {
                        buffer: this.element.pathLog.buffer,
                    },
                },
            ],
        });
    
        this.bindGroup.auxiliary = params.device.createBindGroup({
            label: 'auxiliary bind group',
            layout: this.bindGroupLayout.auxiliary,
            entries: [
                {
                    binding: this.#config.bindGroup.auxiliary.binding.dispatchIndirectParameters,
                    resource: {
                        buffer: this.element.dispatchIndirectParameters.buffer,
                    },
                },
            ],
        });
    }
}

class Debug {
    #label;
    #data;
    #resultBuffer;

    constructor(params) {
        this.#label = params.label;
        this.#data = params.data;
    }

    encode(params) {
        this.#resultBuffer = params.device.createBuffer({
            label: this.#label,
            size: this.#data.buffer.size,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        });
    
        params.encoder.copyBufferToBuffer(this.#data.buffer, 0, this.#resultBuffer, 0, this.#resultBuffer.size);
    }

    async log() {
        await this.#resultBuffer.mapAsync(GPUMapMode.READ);
        const result = this.#resultBuffer.getMappedRange().slice();
        const view = this.#data.getView({ array: result });
        this.#resultBuffer.unmap();
        console.log(`${this.#label}:`);
        for (let key in view) {
            console.log(`${key}:`);
            console.log(view[key]);
        }
    }
}

class Executor {
    #config;
    #data;

    #kernels = {
        primary: {},
        auxiliary: {},
    };

    constructor(params) {
        this.#config = params.config;
        this.#data = params.data;

        this.#kernels.primary.initialize = new InitializeKernel({ 
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.sampleCamera = new SampleCameraKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.sampleLight = new SampleLightKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.intersect = new IntersectKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.sampleMaterial = new SampleMaterialKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.connect = new ConnectKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.postConnectNull = new PostConnectNullKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.postConnectCameraDirect = new PostConnectCameraDirectKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.postConnectCameraIndirect = new PostConnectCameraIndirectKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.postConnectLightDirect = new PostConnectLightDirectKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.postConnectLightIndirect = new PostConnectLightIndirectKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.primary.contribute = new ContributeKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.auxiliary.clearQueue = new ClearQueueKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.auxiliary.dispatch = new DispatchKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.auxiliary.buildCdf = new BuildCdfKernel({
            config: this.#config,
            data: this.#data,
        });

        this.#kernels.auxiliary.startChain = new StartChainKernel({
            config: this.#config,
            data: this.#data,
        });
    }

    initialize(params) {
        this.#kernels.primary.initialize.initialize({ device: params.device });
        this.#kernels.primary.sampleCamera.initialize({ device: params.device });
        this.#kernels.primary.sampleLight.initialize({ device: params.device });
        this.#kernels.primary.intersect.initialize({ device: params.device });
        this.#kernels.primary.sampleMaterial.initialize({ device: params.device });
        this.#kernels.primary.connect.initialize({ device: params.device });
        this.#kernels.primary.postConnectNull.initialize({ device: params.device });
        this.#kernels.primary.postConnectCameraDirect.initialize({ device: params.device });
        this.#kernels.primary.postConnectCameraIndirect.initialize({ device: params.device });
        this.#kernels.primary.postConnectLightDirect.initialize({ device: params.device });
        this.#kernels.primary.postConnectLightIndirect.initialize({ device: params.device });
        this.#kernels.primary.contribute.initialize({ device: params.device });

        this.#kernels.auxiliary.clearQueue.initialize({ device: params.device });
        this.#kernels.auxiliary.dispatch.initialize({ device: params.device });
        this.#kernels.auxiliary.buildCdf.initialize({ device: params.device });
        this.#kernels.auxiliary.startChain.initialize({ device: params.device });
    }

    execute(params) {
        const encoder = params.device.createCommandEncoder({
            label: 'command encoder',
        });

        const querySet = params.device.createQuerySet({
            type: 'timestamp',
            count: 2,
        });

        const pass = encoder.beginComputePass({
            label: 'phase 1 compute pass',
            timestampWrites: {
                querySet,
                beginningOfPassWriteIndex: 0,
                endOfPassWriteIndex: 1,
            },
        });

        for (let pathLength = 4/*this.#config.path.length.min*/; pathLength <= 4/*this.#config.path.length.max*/; pathLength++) {
            const chainId = pathLength - this.#config.path.length.min;

            this.#kernels.primary.initialize.encode({ pathLength, pass, device: params.device });
            this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

            for (let iteration = 1; iteration <= pathLength - 1; iteration++) {
                this.#kernels.primary.sampleCamera.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.sample.camera, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.sampleLight.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.sample.light, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.intersect.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.intersect, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.sampleMaterial.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.sample.material, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.connect.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.connect, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.postConnectNull.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.postConnect.null, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.postConnectCameraDirect.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.postConnect.camera.direct, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.postConnectCameraIndirect.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.postConnect.camera.indirect, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.postConnectLightDirect.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.postConnect.light.direct, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.postConnectLightIndirect.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.postConnect.light.indirect, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });

                this.#kernels.primary.contribute.encode({ pass, device: params.device });

                this.#kernels.auxiliary.clearQueue.encode({ queueId: this.#config.queue.index.contribute, pass, device: params.device });
                this.#kernels.auxiliary.dispatch.encode({ pass, device: params.device });
            }

            this.#kernels.auxiliary.buildCdf.encode({ chainId, pass, device: params.device });

            const random = Math.random();

            this.#kernels.auxiliary.startChain.encode({ chainId, random, pass, device: params.device });
        }

        pass.end();

        const timestamp = new Timestamp();
        timestamp.prepare({ querySet, device: params.device, encoder });

        const debug = new Debug({ label: 'path log', data: this.#data.element.pathLog });
        debug.encode({ encoder, device: params.device });

        const commandBuffer = encoder.finish();
        params.device.queue.submit([commandBuffer]);

        timestamp.log();
        debug.log();
    }
}

class Scene {
    camera = {
        origin: { x: 50.0, y: 40.8, z: 220.0 },
        lookAt: { x: 50.0, y: 40.8, z: 0.0 },
        fieldOfView: 40.0,
    };

    spheres = [
        {
            center: { x: 10.0, y: 70.0, z: 51.6 },
            radius: 6.0,
            color: { r: 31.8309886184, g: 31.8309886184, b: 31.8309886184 },
        },
        {
            center: { x: 10001.0, y: 40.8, z: 81.6 },
            radius: 10000.0,
            color: { r: 0.75, g: 0.25, b: 0.25 },
        },
        {
            center: { x: -9901.0, y: 40.8, z: 81.6 },
            radius: 10000.0,
            color: { r: 0.25, g: 0.25, b: 0.75 },
        },
        {
            center: { x: 50.0, y: 40.8, z: 10000.0 },
            radius: 10000.0,
            color: { r: 0.75, g: 0.65, b: 0.75 }
        },
        {
            center: { x: 50.0, y: 40.8, z: -9650.0 },
            radius: 10000,
            color: { r: 0.50, g: 0.50, b: 0.50 },
        },
        {
            center: { x: 50.0, y: 10000.0, z: 81.6 },
            radius: 10000,
            color: { r: 0.65, g: 0.75, b: 0.75 },
        },
        {
            center: { x: 50.0, y: -9918.4, z: 81.6 },
            radius: 10000,
            color: { r: 0.75, g: 0.75, b: 0.65 },
        },
        {
            center: { x: 50.0, y: 20.0, z: 50.0 },
            radius: 20.0,
            color: { r: 0.25, g: 0.75, b: 0.25 }
        },
        {
            center: { x: 19.0, y: 16.5, z: 25.0 },
            radius: 16.5,
            color: { r: 0.8, g: 0.8, b: 0.8 },
        },
        {
            center: { x: 77.0, y: 16.5, z: 78.0 },
            radius: 16.5,
            color: { r: 1.0, g: 1.0, b: 1.0 },
        },
    ];
}

class Timestamp {
    #resolveBuffer;
    #resultBuffer;

    constructor() {

    }

    prepare(params) {
        this.#resolveBuffer = params.device.createBuffer({
            size: params.querySet.count * 8,
            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
        });

        this.#resultBuffer = params.device.createBuffer({
            size: this.#resolveBuffer.size,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });

        params.encoder.resolveQuerySet(params.querySet, 0, 2, this.#resolveBuffer, 0);

        if (this.#resultBuffer.mapState === 'unmapped') {
            params.encoder.copyBufferToBuffer(this.#resolveBuffer, 0, this.#resultBuffer, 0, this.#resultBuffer.size);
        }
    }

    async log() {
        if (this.#resultBuffer.mapState === 'unmapped') {
            await this.#resultBuffer.mapAsync(GPUMapMode.READ).then(() => {
                const times = new BigInt64Array(this.#resultBuffer.getMappedRange());
                const gpuTime = Number(times[1] - times[0]) / 1_000_000.0;
                console.log(`elapsed time: ${gpuTime} ms.`);
                this.#resultBuffer.unmap();
            });
        }
    }
}

class VectorMath {
    static norm(v) {
        let n = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
        return { x: v.x / n, y: v.y / n, z: v.z / n};
    }
    
    static cross(a, b) {
        return {
            x: a.y * b.z - a.z * b.y,
            y: a.z * b.x - a.x * b.z,
            z: a.x * b.y - a.y * b.x,
        }
    }
    
    static isZero(v) {
        v.x == 0.0 && v.y == 0.0 && v.z == 0.0;
    }
    
    static orthonormalBasis(n) {
        const w = VectorMath.norm(n);
        const ey = { x: 0.0, y: 1.0, z: 0.0 };
        let u = VectorMath.norm(VectorMath.cross(ey, w));
        let v;
        if (VectorMath.isZero(u)) {
            const ex = { x: 1.0, y: 0.0, z: 0.0 };
            v = VectorMath.norm(VectorMath.cross(w, ex));
            u = VectorMath.norm(VectorMath.cross(v, w));
        } else {
            v = VectorMath.norm(VectorMath.cross(w, u));
        }
        return { u, v, w };
    }
    
    static sub(a, b) {
        return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z, };
    }
}

async function main() {
    // Initialize config
    const config = new Config();

    // Request a device
    const adapter = await navigator.gpu?.requestAdapter({
        powerPreference: 'high-performance',
    });

    const device = await adapter?.requestDevice({
        requiredFeatures: ['timestamp-query'],
        requiredLimits: {
            maxStorageBufferBindingSize: config.memory.limit,
            maxBufferSize: config.memory.limit,
        },
    });

    if (!device) {
        alert('Your web browser does not support WebGPU');
        return;
    }

    device.addEventListener('uncapturederror', event => console.log(event.error.message));

    // Create the scene
    const scene = new Scene();

    // Initialize the GPU memory
    const data = new Data({ config, scene });
    data.initialize({ device });

    // Prepare an executor
    const executor = new Executor({ config, data });
    executor.initialize({ device });

    // Execute
    executor.execute({ device });
};

main();

    </script>
</html>
