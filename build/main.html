<html>
    <script type="module">
        const keys = [
'0xc8e4fd154ce32f6d',
'0xfcbd6e154bf53ed9',
'0xea6342c76bf95d47',
'0xfb9e125878fa6cb3',
'0xa1ed294ba7fe8b31',
'0xcf29ba8dc5f1a98d',
'0x815a7d4ed4e3b7f9',
'0x163acbf213f5d867',
'0x674e2d1542f9e6d3',
'0xebc9672872ecf651',
'0xec13a6976ecf14ad',
'0x42c86e3a9de3542b',
'0x5489de2cbce65297',
'0x49bc37fdcad971f3',
'0xd5b4213fe7db8f61',
'0xbf785e3215ac7ebd',
'0x46be329546e1ad3b',
'0x8b7ef19654e3dca7',
'0x1d7683c983d7eb15',
'0x3724b1c872d9fa81',
'0x2af73db87fab18ed',
'0xa185f4cbadcf285b',
'0x53d684c1fbd246c7',
'0x35fda1821cd68735',
'0xfd3791543bd985a1',
'0x7f59c4b657cb941f',
'0x19f3e5b765cea27b',
'0xf6235eca95b2c1e7',
'0x9d827c5ba2b3df45',
'0x8a149e2dc2a6feb1',
'0xa9234cbdcea91d2f',
'0xab134cd21f9c2d8b',
'0x65c48e132c9e3bf7',
'0x7e943bd54dc26b75',
'0x4b3a29d76ab579d1',
'0xfa2871eba6b7984f',
'0x4bd2596ed48c96ab',
'0xa9463c1ed4aec629',
'0x39a5fc81f3b1e495',
'0x72f9c8a323a5e4f1',
'0xb7cf8a2652b8136f',
'0xb372ac465f8932db',
'0x16dab9f87ead5149',
'0xaf9ed4c87b8e4fa5',
'0xbcae598dcba48e13',
'0xd3bc94fed6948c7f',
'0xbacd24f1f4768aeb',
'0xfeca9382147acb59',
'0xf4a18b53237ed9c5',
'0xfa96251875a1f943',
'0xb247ef5982a4179f',
'0x695781dbaf98371d',
'0x782ae64dce8b3579',
'0xad5b918edb8c64e5',
'0x4e98ac3feb9f8463',
'0xd1bc48f21a7382bf',
'0xa763b9e54986a13d',
'0x9d3fe5643456bf89',
'0x7acf9b287369bdf5',
'0x7f4823ba926ced73',
'0x5acef64ba3721bcf',
'0x8af4673dcf752b4d',
'0x2bc59ae1fe563ab9',
'0xb639dc821e6b5a27',
'0x71d692e32c5d6893',
'0x8ec7d3f4394d76ef',
'0x6cf18d298972a56d',
'0xa1c698dba765b4d9',
'0x527f618dc569d347',
'0x167d892ed46ae2b3',
'0x63547dbfe47df231',
'0xf84de9565472318d',
'0xa8e4dc232d543fe9',
'0x89f56da76d384e57',
'0x42ea36b87b496dc3',
'0x17fd98ba9a5d8c41',
'0x763f529cb63f7a9d',
'0xe8794dcfe753c91b',
'0xd7e4f9c1f534d987',
'0x5fa74d621548d7e3',
'0x783c12e6534bf761',
'0xe7c435b8724e15bd',
'0xc1258b6a9f61453b',
'0xae842f6cbe2453a7',
'0x176f8e4dcd498315',
'0xc48512bfec4b9281',
'0x8bd269cfe62a7fcd',
'0x7fbe5932172f9e4b',
'0x34fa7d954632cdb7',
'0xad1b36598736ec25',
'0xc471f3598437fb91',
'0xfec831d9823a19fd',
'0x58f9746baf1e296b',
'0xeb6a512dce2148d7',
'0x635c9b81fd137845',
'0xe32f6dc43d2786b1',
'0x924ec7a54b1a952f',
'0x74af9cd6571da38b',
'0x3bc5d689861eb2f7',
'0xfb6da23cb823e175',
];

const constants = {
    cameraGroup: 0,
    cameraBinding: 0,
    sphereGroup: 0,
    sphereBinding: 1,
    chainGroup: 0,
    chainBinding: 2,
    pathStateGroup: 0,
    pathStateBinding: 3,
    imageGroup: 0,
    imageBinding: 4,
    queuesGroup: 0,
    queuesBinding: 5,
    queueCountsGroup: 0,
    queueCountsBinding: 6,
    dispatchIndirectParametersGroup: 1,
    dispatchIndirectParametersBinding: 0,
    uniformsGroup: 2,
    uniformsBinding: 0,
    workgroupSize: 64,
    maxPathLength: 5,
    pathCount: 1_000_000,
    lightSphereId: 0,
    sphereCount: 10,
    pixelWidth: 640,
    pixelHeight: 480,
    numbersPerVertex: 4,
    queueCount: 6,
    sampleCameraQueueId: 0,
    sampleLightQueueId: 1,
    intersectQueueId: 2,
    sampleMaterialQueueId: 3,
    connectQueueId: 4,
    contributeQueueId: 5,
};

const wgslLib = `
const CAMERA_STREAM_INDEX: u32 = 0;
const LIGHT_STREAM_INDEX: u32 = 1;
const TECHNIQUE_STREAM_INDEX: u32 = 2;

const PI: f32 = 3.14159265358979323846264338327950288;

const NUMBERS_PER_VERTEX: u32 = ${constants.numbersPerVertex};
const MIN_PATH_LENGTH: u32 = 2;
const MAX_PATH_LENGTH: u32 = ${constants.maxPathLength};

const QUEUE_COUNT: u32 = ${constants.queueCount};

const NULL_QUEUE_ID: u32 = 1000;
const SAMPLE_CAMERA_QUEUE_ID: u32 = ${constants.sampleCameraQueueId};
const SAMPLE_LIGHT_QUEUE_ID: u32 = ${constants.sampleLightQueueId};
const INTERSECT_QUEUE_ID: u32 = ${constants.intersectQueueId};
const SAMPLE_MATERIAL_QUEUE_ID: u32 = ${constants.sampleMaterialQueueId};
const CONNECT_QUEUE_ID: u32 = ${constants.connectQueueId};
const CONTRIBUTE_QUEUE_ID: u32 = ${constants.contributeQueueId};

const LIGHT_SPHERE_ID: u32 = ${constants.lightSphereId};

const PATH_COUNT: u32 = ${constants.pathCount};
const SPHERE_COUNT: u32 = ${constants.sphereCount};

const LARGE_STEP_PROBABILITY = 0.3;
const SMALL_STEP: u32 = 0;
const LARGE_STEP: u32 = 1;
const CHAIN_COUNT: u32 = MAX_PATH_LENGTH - MIN_PATH_LENGTH + 1;
const WORKGROUP_SIZE: u32 = ${constants.workgroupSize};

const CAMERA_GROUP: u32 = ${constants.cameraGroup}; 
const CAMERA_BINDING: u32 = ${constants.cameraBinding};
const SPHERE_GROUP: u32 = ${constants.sphereGroup};
const SPHERE_BINDING: u32 = ${constants.sphereBinding};
const CHAIN_GROUP: u32 = ${constants.chainGroup};
const CHAIN_BINDING: u32 = ${constants.chainBinding};
const PATH_STATE_GROUP: u32 = ${constants.pathStateGroup};
const PATH_STATE_BINDING: u32 = ${constants.pathStateBinding};
const IMAGE_GROUP: u32 = ${constants.imageGroup};
const IMAGE_BINDING: u32 = ${constants.imageBinding};
const QUEUES_GROUP: u32 = ${constants.queuesGroup};
const QUEUES_BINDING: u32 = ${constants.queuesBinding}; 
const QUEUE_COUNTS_GROUP: u32 = ${constants.queueCountsGroup};
const QUEUE_COUNTS_BINDING: u32 = ${constants.queueCountsBinding}; 
const DISPATCH_INDIRECT_PARAMETERS_GROUP: u32 = ${constants.dispatchIndirectParametersGroup}; 
const DISPATCH_INDIRECT_PARAMETERS_BINDING: u32 = ${constants.dispatchIndirectParametersBinding};
const UNIFORMS_GROUP: u32 = ${constants.uniformsGroup};
const UNIFORMS_BINDING: u32 = ${constants.uniformsBinding};

const PIXEL_WIDTH: u32 = ${constants.pixelWidth};
const PIXEL_HEIGHT: u32 = ${constants.pixelHeight};
const PIXEL_COUNT: u32 = PIXEL_WIDTH * PIXEL_HEIGHT;

const SIGMA: f32 = 0.01;
const MAX_F32: f32 = 3.40282346638528859812e+38f;

struct Camera {
    u: vec3f,
    v: vec3f,
    w: vec3f,
    origin: vec3f,
    distance: f32,
};

struct Sphere {
    radius: array<f32, SPHERE_COUNT>,
    center_x: array<f32, SPHERE_COUNT>,
    center_y: array<f32, SPHERE_COUNT>,
    center_z: array<f32, SPHERE_COUNT>,
    color_r: array<f32, SPHERE_COUNT>,
    color_g: array<f32, SPHERE_COUNT>,
    color_b: array<f32, SPHERE_COUNT>,
};

struct PathState {
    step_type: array<u32, PATH_COUNT>,
    local_path_index: array<u32, PATH_COUNT>,
    path_length: array<u32, PATH_COUNT>,
    vertex_index: array<u32, PATH_COUNT>,
    ray_origin_x: array<f32, PATH_COUNT>,
    ray_origin_y: array<f32, PATH_COUNT>,
    ray_origin_z: array<f32, PATH_COUNT>,
    ray_direction_x: array<f32, PATH_COUNT>,
    ray_direction_y: array<f32, PATH_COUNT>,
    ray_direction_z: array<f32, PATH_COUNT>,
    scalar_contribution: array<f32, PATH_COUNT>,
};

struct U64 {
  hi: u32,
  lo: u32,
};

struct Technique {
    camera: u32,
    light: u32,
};

struct Basis {
    u: vec3f,
    v: vec3f,
    w: vec3f,
};

struct MarkovChain {
    key_hi: array<u32, CHAIN_COUNT>,
    key_lo: array<u32, CHAIN_COUNT>,
    iteration: array<u32, CHAIN_COUNT>,
    numbers_per_iteration: array<u32, CHAIN_COUNT>,
    numbers_per_path: array<u32, CHAIN_COUNT>,
    numbers_per_stream: array<u32, CHAIN_COUNT>,
    large_step_index_hi: array<u32, CHAIN_COUNT>,
    large_step_index_lo: array<u32, CHAIN_COUNT>,
    small_step_count: array<u32, CHAIN_COUNT>,
};

struct RandomParameters {
  step_type: u32,
  local_path_index: u32,
  numbers_per_path: u32,
  stream_index: u32,
  numbers_per_stream: u32,
  vertex_index: u32,
  iteration: u32,
  numbers_per_iteration: u32,
  large_step_index: U64,
  key: U64,
  small_step_count: u32,
};

struct Image {
    r: array<atomic<u32>, PIXEL_COUNT>,
    g: array<atomic<u32>, PIXEL_COUNT>,
    b: array<atomic<u32>, PIXEL_COUNT>,
};

struct InitializeUniforms {
    path_length: u32,
};

struct ClearQueueUniforms {
    queue_id: u32,
}

struct BuildCdfUniforms {
    min_path_index: u32,
    path_count: u32,
    iteration: u32,
};

struct Intersection {
    point: vec3f,
    normal: vec3f,
    valid: bool,
};

struct Ray {
    origin: vec3f,
    direction: vec3f,
};

struct PixelCoordinates {
    x: u32,
    y: u32,
    valid: bool,
};

struct MaterialSample {
    wi: vec3f,
    pdf: f32,
    valid: bool,
};

@group(CAMERA_GROUP) @binding(CAMERA_BINDING) var<storage, read> camera: Camera;
@group(SPHERE_GROUP) @binding(SPHERE_BINDING) var<storage, read> sphere: Sphere;
@group(CHAIN_GROUP) @binding(CHAIN_BINDING) var<storage, read_write> chain: MarkovChain;
@group(PATH_STATE_GROUP) @binding(PATH_STATE_BINDING) var<storage, read_write> path_state: PathState;
@group(IMAGE_GROUP) @binding(IMAGE_BINDING) var<storage, read_write> image: Image;
@group(QUEUES_GROUP) @binding(QUEUES_BINDING) var<storage, read_write> queues: array<array<u32, PATH_COUNT>, QUEUE_COUNT>;
@group(QUEUE_COUNTS_GROUP) @binding(QUEUE_COUNTS_BINDING) var<storage, read_write> queue_counts: array<atomic<u32>, QUEUE_COUNT>;
@group(DISPATCH_INDIRECT_PARAMETERS_GROUP) @binding(DISPATCH_INDIRECT_PARAMETERS_BINDING) var<storage, read_write> dispatch_indirect_parameters: array<vec3u, QUEUE_COUNT>;

var<workgroup> workgroup_queue_ballot: array<u32, WORKGROUP_SIZE>;

fn rand(p: RandomParameters, number_index: u32) -> f32 {
    let stream_offset = p.stream_index * p.numbers_per_stream 
      +  p.vertex_index * NUMBERS_PER_VERTEX 
      + number_index;
    let path_offset = p.local_path_index * p.numbers_per_path + stream_offset;
    let index = u64_add(u64_mul(u64_from(p.iteration), u64_from(p.numbers_per_iteration)), u64_from(path_offset));
    let random_number = squares32(index, p.key);
    if  p.step_type == LARGE_STEP {
        return random_number;
    } else {
        let index = u64_add(p.large_step_index, u64_from(stream_offset));
        let value = squares32(index, p.key);
        let perturbation = SIGMA
          * sqrt(f32(p.small_step_count)) 
          * sqrt(2.0) 
          * erf_inv(2.0 * random_number - 1.0);
        return value + perturbation;
    }
}

fn get_random_parameters(global_path_index: u32, stream_index: u32) -> RandomParameters {
  let path_length = path_state.path_length[global_path_index];
  let chain_index = path_length - MIN_PATH_LENGTH;
  let step_type = path_state.step_type[global_path_index];
  let local_path_index = path_state.local_path_index[global_path_index];
  let vertex_index = path_state.vertex_index[global_path_index];
  return RandomParameters(
    step_type, 
    local_path_index, 
    chain.numbers_per_path[chain_index], 
    stream_index, 
    chain.numbers_per_stream[chain_index], 
    vertex_index, 
    chain.iteration[chain_index], 
    chain.numbers_per_iteration[chain_index], 
    U64(chain.large_step_index_hi[chain_index], chain.large_step_index_lo[chain_index]), 
    U64(chain.key_hi[chain_index], chain.key_lo[chain_index]),
    chain.small_step_count[chain_index]
  );
}

fn rand_1(global_path_index: u32, stream_index: u32) -> f32 {
  let p = get_random_parameters(global_path_index, stream_index);
  return rand(p, 0);
}

fn rand_2(global_path_index: u32, stream_index: u32) -> vec2f {
  let p = get_random_parameters(global_path_index, stream_index);
  let r1 = rand(p, 0);
  let r2 = rand(p, 1);
  return vec2f(r1, r2);
}

fn rand_4(global_path_index: u32, stream_index: u32) -> vec4f {
  let p = get_random_parameters(global_path_index, stream_index);
  let r1 = rand(p, 0);
  let r2 = rand(p, 1);
  let r3 = rand(p, 2);
  let r4 = rand(p, 3);
  return vec4f(r1, r2, r3, r4);
}

fn u64_from(lo: u32) -> U64 {
    return U64(0, lo);
}

fn squares32(ctr: U64, key: U64) -> f32 {
  var x = u64_mul(ctr, key);
  var y = x;
  var z = u64_add(y, key);

  x = squares32_round(x, y);
  x = squares32_round(x, z);
  x = squares32_round(x, y);
  x = squares32_round(x, z);

  return squares32_bitcast(x.hi);
}

fn squares32_bitcast(u: u32) -> f32 {
  return bitcast<f32>((u >> 9) | 0x3f800000) - 1.0;
}

fn squares32_round(a: U64, b: U64) -> U64 {
  return u64_swp(u64_add(u64_sqr(a), b));
}

fn u64_add(a: U64, b: U64) -> U64 {
  let lo_sum = a.lo + b.lo;
  let carry = u32(lo_sum < a.lo);
  return U64(a.hi + b.hi + carry, lo_sum);
}

fn u64_mul(a: U64, b: U64) -> U64 {
  let hi = u32_mul_hi(a.lo, b.lo);
  return U64(a.hi * b.lo + a.lo * b.hi + hi, a.lo * b.lo);
}

fn u64_sqr(a: U64) -> U64 {
  let hi = u32_mul_hi(a.lo, a.lo);
  return U64(2 * a.hi * a.lo + hi, a.lo * a.lo);
}

fn u64_swp(a: U64) -> U64 {
  return U64(a.lo, a.hi);
}

fn u32_mul_hi(a: u32, b: u32) -> u32 {
  let ah = a >> 16;
  let bh = b >> 16;
  let al = a & 0xffff;
  let bl = b & 0xffff;
  let albl = al * bl;
  let ahbl = ah * bl;
  let albh = al * bh;
  let sum = (ahbl & 0xffff) + (albh & 0xffff) + (albl >> 16);
  return ah * bh + (ahbl >> 16) + (albh >> 16) + (sum >> 16);
}

fn erf_inv(x: f32) -> f32 {
    let xc = clamp(x, -0.99999, 0.99999);
    var w = log((1.0 - xc) * (1.0 + xc));
    if w < 5.0 {
        w = w - 2.5;
        var p = 2.81022636e-08;
        p = 3.43273939e-07 + p * w;
        p = -3.5233877e-06 + p * w;
        p = -4.39150654e-06 + p * w;
        p = 0.00021858087 + p * w;
        p = -0.00125372503 + p * w;
        p = -0.00417768164 + p * w;
        p = 0.246640727 + p * w;
        p = 1.50140941 + p * w;
        return p * x;
    } else {
        w = sqrt(w) - 3.0;
        var p = -0.000200214257;
        p = 0.000100950558 + p * w;
        p = 0.00134934322 + p * w;
        p = -0.00367342844 + p * w;
        p = 0.00573950773 + p * w;
        p = -0.0076224613 + p * w;
        p = 0.00943887047 + p * w;
        p = 1.00167406 + p * w;
        p = 2.83297682 + p * w;
        return p * x;
    }
}

fn sample_technique(path_length: u32, r: f32) -> Technique {
    let camera = 1 + u32(r * f32(path_length)); // pinhole camera; at least one camera vertex
    let light = path_length - camera;
    return Technique(camera, light);
}

fn uniform_sample_sphere(u1: f32, u2: f32) -> vec3f {
    let z = 1.0 - 2.0 * u1;
    let r = sqrt(max(0.0, 1.0 - z * z));
    let phi = 2.0 * PI * u2;
    return vec3f(r * cos(phi), r * sin(phi), z);
}

fn cosine_sample_hemisphere(n: vec3f, u1: f32, u2: f32) -> vec3f {
    // Sample a unit disk in R^2
    let xy = concentric_sample_disk(u1, u2);

    // Compute an orthonormal basis relative to n as the "z" direction
    let b = orthonormal_basis(n);

    // Compute the coordinates in this new orthonormal basis relative to the normal vector nz
    let z = sqrt(max(0.0, 1.0 - xy.x * xy.x - xy.y * xy.y));

    // Done
    return b.u * xy.x + b.v * xy.y + b.w * z;
}

fn concentric_sample_disk(u1: f32, u2: f32) -> vec2f {
    // Map uniform random numbers to $[-1,1]^2$
    let u_offset_x = 2.0 * u1 - 1.0;
    let u_offset_y = 2.0 * u2 - 1.0;

    // Handle degeneracy at the origin
    if u_offset_x == 0.0 && u_offset_y == 0.0 {
        return vec2f(0.0, 0.0);
    }

    // Apply concentric mapping to point
    var r: f32;
    var theta: f32;
    if abs(u_offset_x) > abs(u_offset_y) {
        r = u_offset_x;
        theta = (PI / 4.0) * (u_offset_y / u_offset_x);
    } else {
        r = u_offset_y;
        theta = (PI / 2.0) - ((PI / 4.0) * (u_offset_x / u_offset_y));
    }

    // Done
    return vec2f(r * cos(theta), r * sin(theta));
}

fn is_zero(v: vec3f) -> bool {
    return v.x == 0.0 && v.y == 0.0 && v.z == 0.0;
}

fn orthonormal_basis(n: vec3f) -> Basis {
    let nz = normalize(n);
    let ey = vec3f(0.0, 1.0, 0.0);
    var nx = normalize(cross(ey, nz));
    var ny: vec3f;
    if is_zero(nx) {
        let ex = vec3f(1.0, 0.0, 0.0);
        ny = normalize(cross(nz, ex));
        nx = normalize(cross(ny, nz));
    } else {
        ny = normalize(cross(nz, nx));
    };
    return Basis(nx, ny, nz);
}

fn choose_u32(b: bool, u1: u32, u2: u32) -> u32 {
    return u32(b) * u1 + u32(!b) * u2;
}

fn intersect_sphere(center: vec3f, radius: f32, ray: Ray) -> f32 {
    let c = center - ray.origin;
    let b = dot(c, ray.direction);
    var det = b * b - dot(c, c) + radius * radius;
    if det < 0.0 {
        return MAX_F32;
    }
    det = sqrt(det);
    let threshold = 1e-4;
    var t = b - det;
    if t <= threshold {
        t = b + det;
        if t <= threshold {
            return MAX_F32;
        }
    }
    return t;
}

fn intersect(ray: Ray) -> Intersection {
    var best_t: f32 = MAX_F32;
    var best_sphere_id: u32 = 0;

    for (var i: u32 = 0; i < SPHERE_COUNT; i++) {
        let center = vec3f(sphere.center_x[i], sphere.center_y[i], sphere.center_z[i]);
        let radius = sphere.radius[i];
        let t = intersect_sphere(center, radius, ray);
        best_sphere_id = choose_u32(t < best_t, i, best_sphere_id);
        best_t = min(t, best_t);
    }

    let point = ray.origin + ray.direction * best_t;
    let center = vec3f(sphere.center_x[best_sphere_id], sphere.center_y[best_sphere_id], sphere.center_z[best_sphere_id]);
    let normal = normalize(point - center);

    return Intersection(point, normal, best_t < MAX_F32);
}

fn approx_eq_f32(a: f32, b: f32, tolerance: f32) -> bool {
    return abs(a - b) < tolerance;
}

fn approx_eq_vec3f(a: vec3f, b: vec3f, tolerance: f32) -> bool {
    return approx_eq_f32(a.x, b.x, tolerance) && approx_eq_f32(a.y, b.y, tolerance) && approx_eq_f32(a.z, b.z, tolerance);
}

fn get_pixel_coordinates(ray: Ray) -> PixelCoordinates {
    let d = normalize(ray.origin - camera.origin);
    let screen_center = camera.w * camera.distance;
    let wd = dot(camera.w, d);
    if wd == 0.0 {
        return PixelCoordinates(0, 0, false);
    }
    let t = dot(camera.w, screen_center) / wd;
    if t <= 0.0 {
        return PixelCoordinates(0, 0, false);
    }
    let p = t * d - screen_center;
    let px = u32(dot(camera.u, p) + f32(PIXEL_WIDTH) * 0.5);
    let py = u32(-dot(camera.v, p) + f32(PIXEL_HEIGHT) * 0.5);
    if 0 <= px && px < PIXEL_WIDTH && 0 <= py && py < PIXEL_HEIGHT {
        return PixelCoordinates(px, py, true);
    }
    return PixelCoordinates(0, 0, false);
}

fn sample_matte_material(normal: vec3f, u: vec2f) -> MaterialSample {
    let wi = cosine_sample_hemisphere(normal, u[0], u[1]);
    let pdf = abs_cos_theta(normal, wi) / PI;
    return MaterialSample(wi, pdf, true);
}

fn abs_cos_theta(n: vec3f, v: vec3f) -> f32 {
    return abs(dot(normalize(n), normalize(v)));
}

// TODO: maybe use workgroup_id instead of global_invocation_id; let id = workgroup_index * WORKGROUP_SIZE + i;
fn enqueue(global_invocation_id: u32, local_invocation_id: u32, queue_id: u32) {
    workgroup_queue_ballot[local_invocation_id] = queue_id;

    workgroupBarrier();

    if local_invocation_id >= QUEUE_COUNT {
        return;
    }

    var tally: u32 = 0;

    for (var i: u32 = 0; i < WORKGROUP_SIZE; i++) {
        let queue_index = workgroup_queue_ballot[i];
        tally = tally + u32(queue_index == local_invocation_id);
    }

    if tally == 0 {
        return;
    }

    var index = atomicAdd(&queue_counts[local_invocation_id], tally);
    let last_index = index + tally - 1;

    for (var i: u32 = 0; i < WORKGROUP_SIZE; i++) {
        let queue_index = workgroup_queue_ballot[i];
        let id = global_invocation_id - local_invocation_id + i;
        let index_match = queue_index == local_invocation_id;
        queues[queue_index][index] = choose_u32(index_match, id, queues[queue_index][index]);
        index = index + u32(index_match && index < last_index);
    }
}

fn contribute(contribution: vec3f, x: u32, y: u32) {
    let scale = 1024.0 * 1024.0 * 1024.0;
    let r = u32(contribution.x * scale);
    let g = u32(contribution.y * scale);
    let b = u32(contribution.z * scale);
    let i = y * PIXEL_WIDTH + x;
    atomicAdd(&image.r[i], r);
    atomicAdd(&image.g[i], g);
    atomicAdd(&image.b[i], b);
}

fn read_image(x: u32, y: u32) -> vec3f {
    let scale = 1024.0 * 1024.0 * 1024.0;
    let i = y * PIXEL_WIDTH + x;
    let r = f32(atomicLoad(&image.r[i])) / scale;
    let g = f32(atomicLoad(&image.r[i])) / scale;
    let b = f32(atomicLoad(&image.r[i])) / scale;
    // TODO: tone-map, gamma-correct
    return vec3f(r, g, b);
}
`;

const initializeModuleCode = `
${wgslLib}

@group(UNIFORMS_GROUP) @binding(UNIFORMS_BINDING) var<uniform> uniforms: InitializeUniforms;

@compute
@workgroup_size(WORKGROUP_SIZE)
fn initialize(@builtin(global_invocation_id) id: vec3u, @builtin(local_invocation_index) lid: u32) {
    let global_path_index = id.x;
    var queue_id: u32 = NULL_QUEUE_ID;    
    if global_path_index < PATH_COUNT {
        path_state.step_type[global_path_index] = LARGE_STEP;
        path_state.local_path_index[global_path_index] = global_path_index;
        path_state.path_length[global_path_index] = uniforms.path_length;
        path_state.vertex_index[global_path_index] = 0;
        path_state.scalar_contribution[global_path_index] = 1.0; // TODO fix; temporary for testing
        queue_id = SAMPLE_CAMERA_QUEUE_ID;
    }
    enqueue(global_path_index, lid, queue_id);
}
`;

const sampleCameraModuleCode = `
${wgslLib}

@compute 
@workgroup_size(WORKGROUP_SIZE)
fn sample_camera(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    let global_invocation_index = gid.x;

    var queue_id: u32 = NULL_QUEUE_ID;

    if global_invocation_index < atomicLoad(&queue_counts[SAMPLE_CAMERA_QUEUE_ID]) {
        let global_path_index = queues[SAMPLE_CAMERA_QUEUE_ID][global_invocation_index];
        let tr = rand_1(global_path_index, TECHNIQUE_STREAM_INDEX);
        let path_length = path_state.path_length[global_path_index];
        let technique = sample_technique(path_length, tr);
        queue_id = choose_u32(path_length == 2, SAMPLE_LIGHT_QUEUE_ID, INTERSECT_QUEUE_ID);
        let cr = rand_2(global_path_index, CAMERA_STREAM_INDEX);
        let u = camera.u * (cr[0] - f32(PIXEL_WIDTH) / 2.0);
        let v = -camera.v * (cr[1] - f32(PIXEL_HEIGHT) / 2.0);
        let w = camera.w * camera.distance;
        let direction = normalize(u + v + w);
        path_state.ray_origin_x[global_path_index] = camera.origin.x;
        path_state.ray_origin_y[global_path_index] = camera.origin.y;
        path_state.ray_origin_z[global_path_index] = camera.origin.z;
        path_state.ray_direction_x[global_path_index] = direction.x;
        path_state.ray_direction_y[global_path_index] = direction.y;
        path_state.ray_direction_z[global_path_index] = direction.z;
    }
    
    enqueue(global_invocation_index, lid, queue_id);
}
`;

const sampleLightModuleCode = `
${wgslLib}

@compute 
@workgroup_size(WORKGROUP_SIZE)
fn sample_light(@builtin(global_invocation_id) gid: vec3u, @builtin(local_invocation_index) lid: u32) {
    let global_invocation_index = gid.x;

    var queue_id: u32 = NULL_QUEUE_ID;

    if global_invocation_index < atomicLoad(&queue_counts[SAMPLE_LIGHT_QUEUE_ID]) {
        let global_path_index = queues[SAMPLE_LIGHT_QUEUE_ID][global_invocation_index];
        let tr = rand_1(global_path_index, TECHNIQUE_STREAM_INDEX);
        let path_length = path_state.path_length[global_path_index];
        let technique = sample_technique(path_length, tr);
        queue_id = choose_u32(path_length == 2, CONNECT_QUEUE_ID, INTERSECT_QUEUE_ID);
        let cr = rand_4(global_path_index, LIGHT_STREAM_INDEX);
        let point = uniform_sample_sphere(cr[0], cr[1]) * sphere.radius[LIGHT_SPHERE_ID];
        let center = vec3f(sphere.center_x[LIGHT_SPHERE_ID], sphere.center_y[LIGHT_SPHERE_ID], sphere.center_z[LIGHT_SPHERE_ID]);
        let normal = point - center;
        let direction = cosine_sample_hemisphere(normal, cr[2], cr[3]);
        path_state.ray_origin_x[global_path_index] = point.x;
        path_state.ray_origin_y[global_path_index] = point.y;
        path_state.ray_origin_z[global_path_index] = point.z;
        path_state.ray_direction_x[global_path_index] = direction.x;
        path_state.ray_direction_y[global_path_index] = direction.y;
        path_state.ray_direction_z[global_path_index] = direction.z;
    }
    
    enqueue(global_invocation_index, lid, queue_id);
}
`;

const dispatchModuleCode = `
${wgslLib}

@compute
@workgroup_size(1)
fn dispatch() {
    for (var queue_id: u32 = 0; queue_id < QUEUE_COUNT; queue_id++) {
        let count = atomicLoad(&queue_counts[queue_id]);
        let workgroup_count = u32(ceil(f32(count) / f32(WORKGROUP_SIZE)));
        dispatch_indirect_parameters[queue_id] = vec3u(workgroup_count, 1, 1);
    }
}
`;

const clearQueueModuleCode = `
${wgslLib}

@group(UNIFORMS_GROUP) @binding(UNIFORMS_BINDING) var<uniform> uniforms: ClearQueueUniforms;

@compute
@workgroup_size(1)
fn clear_queue() {
    atomicStore(&queue_counts[uniforms.queue_id], 0);
}
`;

const intersectModuleCode = `
${wgslLib}

@compute
@workgroup_size(WORKGROUP_SIZE)
fn intersect_main(@builtin(global_invocation_id) id: vec3u, @builtin(local_invocation_index) lid: u32) {
    let global_invocation_index: u32 = id.x;
    var queue_id: u32 = NULL_QUEUE_ID;

    if global_invocation_index < atomicLoad(&queue_counts[INTERSECT_QUEUE_ID]) {
        let global_path_index = queues[INTERSECT_QUEUE_ID][global_invocation_index];
        let ray_origin = vec3f(path_state.ray_origin_x[global_path_index], path_state.ray_origin_y[global_path_index], path_state.ray_origin_z[global_path_index]);
        let ray_direction = vec3f(path_state.ray_direction_x[global_path_index], path_state.ray_direction_y[global_path_index], path_state.ray_direction_z[global_path_index]);
        let ray = Ray(ray_origin, ray_direction);
        let intersection = intersect(ray);
        let path_length = path_state.path_length[global_path_index];
        let vertex_index = path_state.vertex_index[global_path_index];
        let light_technique: u32 = 0;//path_state.light_technique[global_path_index]; TODO
        let camera_technique: u32 = 0;//path_state.camera_technique[global_path_index]; TODO
        queue_id = choose_u32(vertex_index + 1 < camera_technique || vertex_index + 1 < light_technique, SAMPLE_MATERIAL_QUEUE_ID, queue_id);
        queue_id = choose_u32(vertex_index == path_length - 1, CONNECT_QUEUE_ID, queue_id);
        queue_id = choose_u32(vertex_index == camera_technique - 1 && light_technique == 0, CONTRIBUTE_QUEUE_ID, queue_id);
        queue_id = choose_u32(vertex_index == camera_technique - 1, SAMPLE_LIGHT_QUEUE_ID, queue_id);
        queue_id = choose_u32(intersection.valid, queue_id, NULL_QUEUE_ID);
    }

    enqueue(global_invocation_index, lid, queue_id);
}
`;

const buildCdfModuleCode = `
${wgslLib}

@group(UNIFORMS_GROUP) @binding(UNIFORMS_BINDING) var<uniform> uniforms: BuildCdfUniforms;

@compute
@workgroup_size(WORKGROUP_SIZE)
fn build_cdf(@builtin(global_invocation_id) id: vec3u) {
    let global_invocation_index = id.x;
    if global_invocation_index >= uniforms.path_count {
        return;
    }
    let i = uniforms.iteration;
    let two_pow_i: u32 = u32(1) << i;
    let m = u32(global_invocation_index >= two_pow_i);
    let j = uniforms.min_path_index + global_invocation_index;
    path_state.scalar_contribution[j] = path_state.scalar_contribution[j] + f32(m) * path_state.scalar_contribution[j - m * two_pow_i];
}
`;

const scene = {
    camera: {
        origin: { x: 50.0, y: 40.8, z: 220.0 },
        lookAt: { x: 50.0, y: 40.8, z: 0.0 },
        fieldOfView: 40.0,
    },
    spheres: [
        {
            center: { x: 10.0, y: 70.0, z: 51.6 },
            radius: 6.0,
            color: { r: 31.8309886184, g: 31.8309886184, b: 31.8309886184 },
        },
        {
            center: { x: 10001.0, y: 40.8, z: 81.6 },
            radius: 10000.0,
            color: { r: 0.75, g: 0.25, b: 0.25 },
        },
        {
            center: { x: -9901.0, y: 40.8, z: 81.6 },
            radius: 10000.0,
            color: { r: 0.25, g: 0.25, b: 0.75 },
        },
        {
            center: { x: 50.0, y: 40.8, z: 10000.0 },
            radius: 10000.0,
            color: { r: 0.75, g: 0.65, b: 0.75 }
        },
        {
            center: { x: 50.0, y: 40.8, z: -9650.0 },
            radius: 10000,
            color: { r: 0.50, g: 0.50, b: 0.50 },
        },
        {
     
            center: { x: 50.0, y: 10000.0, z: 81.6 },
            radius: 10000,
            color: { r: 0.65, g: 0.75, b: 0.75 },
        },
        {
            center: { x: 50.0, y: -9918.4, z: 81.6 },
            radius: 10000,
            color: { r: 0.75, g: 0.75, b: 0.65 },
        },
        {
            center: { x: 50.0, y: 20.0, z: 50.0 },
            radius: 20.0,
            color: { r: 0.25, g: 0.75, b: 0.25 }
        },
        {
            center: { x: 19.0, y: 16.5, z: 25.0 },
            radius: 16.5,
            color: { r: 0.8, g: 0.8, b: 0.8 },
        },
        {
            center: { x: 77.0, y: 16.5, z: 78.0 },
            radius: 16.5,
            color: { r: 1.0, g: 1.0, b: 1.0 },
        },
    ],
};

function norm(v) {
    let n = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    return { x: v.x / n, y: v.y / n, z: v.z / n};
}

function cross(a, b) {
    return {
        x: a.y * b.z - a.z * b.y,
        y: a.z * b.x - a.x * b.z,
        z: a.x * b.y - a.y * b.x,
    }
}

function isZero(v) {
    v.x == 0.0 && v.y == 0.0 && v.z == 0.0;
}

function orthonormalBasis(n) {
    const w = norm(n);
    const ey = { x: 0.0, y: 1.0, z: 0.0 };
    let u = norm(cross(ey, w));
    let v;
    if (isZero(u)) {
        const ex = { x: 1.0, y: 0.0, z: 0.0 };
        v = norm(cross(w, ex));
        u = norm(cross(v, w));
    } else {
        v = norm(cross(w, u));
    }
    return { u, v, w };
}

function sub(a, b) {
    return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z, };
}

function parseKey(key) {
    const hi = parseInt(key.substring(2, 10), 16);
    const lo = parseInt(key.substring(10), 16);
    return { hi, lo };
}

function getQueuesArrayViews(queuesArray) { 
    return [
        new Uint32Array(queuesArray, 0, constants.pathCount),
        new Uint32Array(queuesArray, 4 * constants.pathCount, constants.pathCount),
        new Uint32Array(queuesArray, 8 * constants.pathCount, constants.pathCount),
        new Uint32Array(queuesArray, 12 * constants.pathCount, constants.pathCount),
        new Uint32Array(queuesArray, 16 * constants.pathCount, constants.pathCount),
        new Uint32Array(queuesArray, 20 * constants.pathCount, constants.pathCount),
  ];
}

function getQueueCountsArrayViews(queueCountsArray) {
    return [new Uint32Array(queueCountsArray)];
}

function getCameraArrayViews(cameraArray) {
    return {
        u: new Float32Array(cameraArray, 0, 3),
        v: new Float32Array(cameraArray, 16, 3),
        w: new Float32Array(cameraArray, 32, 3),
        origin: new Float32Array(cameraArray, 48, 3),
        distance: new Float32Array(cameraArray, 60, 1),
    };
}

function getSphereArrayViews(sphereArray) {
    return {
        radius: new Float32Array(sphereArray, 0, scene.spheres.length),
        center_x: new Float32Array(sphereArray, 4 * scene.spheres.length, scene.spheres.length),
        center_y: new Float32Array(sphereArray, 8 * scene.spheres.length, scene.spheres.length),
        center_z: new Float32Array(sphereArray, 12 * scene.spheres.length, scene.spheres.length),
        color_r: new Float32Array(sphereArray, 16 * scene.spheres.length, scene.spheres.length),
        color_g: new Float32Array(sphereArray, 20 * scene.spheres.length, scene.spheres.length),
        color_b: new Float32Array(sphereArray, 24 * scene.spheres.length, scene.spheres.length),
    };
}

function getChainArrayViews(chainArray) {
    const chainCount = constants.maxPathLength - 1;
    return {
        key_hi: new Uint32Array(chainArray, 0, chainCount),
        key_lo: new Uint32Array(chainArray, 4 * chainCount, chainCount),
        iteration: new Uint32Array(chainArray, 8 * chainCount, chainCount),
        numbers_per_iteration: new Uint32Array(chainArray, 12 * chainCount, chainCount),
        numbers_per_path: new Uint32Array(chainArray, 16 * chainCount, chainCount),
        numbers_per_stream: new Uint32Array(chainArray, 20 * chainCount, chainCount),
        large_step_index_hi: new Uint32Array(chainArray, 24 * chainCount, chainCount),
        large_step_index_lo: new Uint32Array(chainArray, 28 * chainCount, chainCount),
        small_step_count: new Uint32Array(chainArray, 32 * chainCount, chainCount),
    };
}

function getPathStateArrayViews(pathStateArray) {
    return {
        step_type: new Uint32Array(pathStateArray, 0, constants.pathCount),
        local_path_index: new Uint32Array(pathStateArray, 4 * constants.pathCount, constants.pathCount),
        path_length: new Uint32Array(pathStateArray, 8 * constants.pathCount, constants.pathCount),
        vertex_index: new Uint32Array(pathStateArray, 12 * constants.pathCount, constants.pathCount),
        ray_origin_x: new Float32Array(pathStateArray, 16 * constants.pathCount, constants.pathCount),
        ray_origin_y: new Float32Array(pathStateArray, 20 * constants.pathCount, constants.pathCount),
        ray_origin_z: new Float32Array(pathStateArray, 24 * constants.pathCount, constants.pathCount),
        ray_direction_x: new Float32Array(pathStateArray, 28 * constants.pathCount, constants.pathCount),
        ray_direction_y: new Float32Array(pathStateArray, 32 * constants.pathCount, constants.pathCount),
        ray_direction_z: new Float32Array(pathStateArray, 36 * constants.pathCount, constants.pathCount),
        scalar_contribution: new Float32Array(pathStateArray, 40 * constants.pathCount, constants.pathCount),
    };
}

function configureCamera() {
    const cameraArray = new ArrayBuffer(64);

    const cameraArrayViews = getCameraArrayViews(cameraArray);

    const direction = sub(scene.camera.lookAt, scene.camera.origin);
    const distance = constants.pixelHeight / (2.0 * Math.tan(scene.camera.fieldOfView / 2.0));
    const basis = orthonormalBasis(direction);
    cameraArrayViews.u.set([basis.u.x, basis.u.y, basis.u.z]);
    cameraArrayViews.v.set([basis.v.x, basis.v.y, basis.v.z]);
    cameraArrayViews.w.set([basis.w.x, basis.w.y, basis.w.z]);
    cameraArrayViews.origin.set([scene.camera.origin.x, scene.camera.origin.y, scene.camera.origin.z]);
    cameraArrayViews.distance.set([distance]);

    return cameraArray;
}

function configureScene() {
    const sphereArray = new ArrayBuffer(28 * scene.spheres.length);

    const sphereArrayViews = getSphereArrayViews(sphereArray);

    for (let i = 0; i < scene.spheres.length; i++) {
        const sphere = scene.spheres[i];
        sphereArrayViews.radius.set([sphere.radius], i);
        sphereArrayViews.center_x.set([sphere.center.x], i);
        sphereArrayViews.center_y.set([sphere.center.y], i);
        sphereArrayViews.center_z.set([sphere.center.z], i);
        sphereArrayViews.color_r.set([sphere.color.r], i);
        sphereArrayViews.color_g.set([sphere.color.g], i);
        sphereArrayViews.color_b.set([sphere.color.b], i);
    }

    return sphereArray;
}

function configureChains() {
    const chainCount = constants.maxPathLength - 1;
    const chainArray = new ArrayBuffer(36 * chainCount);

    const chainArrayViews = getChainArrayViews(chainArray);

    for (let i = 0; i < chainCount; i++) {
        const key = parseKey(keys[i]);
        chainArrayViews.key_hi.set([key.hi], i);
        chainArrayViews.key_lo.set([key.lo], i);
        chainArrayViews.iteration.set([0], i);
        const vertexCount = i + 2;
        const numbersPerStream = vertexCount * constants.numbersPerVertex;
        const numbersPerPath = 2 * numbersPerStream + 1;
        const numbersPerIteration = numbersPerPath * constants.pathCount;
        chainArrayViews.numbers_per_iteration.set([numbersPerIteration], i);
        chainArrayViews.numbers_per_path.set([numbersPerPath], i);
        chainArrayViews.numbers_per_stream.set([numbersPerStream], i);
        chainArrayViews.large_step_index_hi.set([0], i);
        chainArrayViews.large_step_index_lo.set([0], i);
    }

    return chainArray;
}

function configureQueueCounts() {
    const queueCountsArray = new Uint32Array(Array(constants.queueCount).fill(0));
    return queueCountsArray;
}

function configureDispatchIndirectParameters() {
    return new Uint32Array(Array(4 * constants.queueCount).fill(0));
}

function configureInitializeUniforms(params) {
    const uniformsArray = new ArrayBuffer(4);
    const uniformsViews = {
        path_length: new Uint32Array(uniformsArray, 0, 1),
    };
    uniformsViews.path_length.set([params.path_length]);
    return uniformsArray;
}

function configureClearQueueUniforms(params) {
    const uniformsArray = new ArrayBuffer(4);
    const uniformsViews = {
        queue_id: new Uint32Array(uniformsArray, 0, 1),
    };
    uniformsViews.queue_id.set([params.queue_id]);
    return uniformsArray;
}

function configureBuildCdfUniforms(params) {
    const uniformsArray = new ArrayBuffer(12);
    const uniformsViews = {
        min_path_index: new Uint32Array(uniformsArray, 0, 1),
        path_count: new Uint32Array(uniformsArray, 4, 1),
        iteration: new Uint32Array(uniformsArray, 8, 1),
    };
    uniformsViews.min_path_index.set([params.min_path_index]);
    uniformsViews.path_count.set([params.path_count]);
    uniformsViews.iteration.set([params.iteration]);
    return uniformsArray;
}

function prepareDebug(device, buffer, encoder, getView, title) {
    const resultBuffer = device.createBuffer({
        label: 'result buffer',
        size: buffer.size,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });

    encoder.copyBufferToBuffer(buffer, 0, resultBuffer, 0, resultBuffer.size);

    return { resultBuffer, getView, title };
}

async function debug(d) {
    await d.resultBuffer.mapAsync(GPUMapMode.READ);
    const result = d.resultBuffer.getMappedRange().slice();
    const view = d.getView(result);
    d.resultBuffer.unmap();
    console.log(`${d.title}:`);
    for (let key in view) {
        console.log(`${key}:`);
        console.log(view[key]);
    }
}

function prepareTimestamp(device, querySet, encoder) {
    const resolveBuffer = device.createBuffer({
        size: querySet.count * 8,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
    });
    const resultBuffer = device.createBuffer({
        size: resolveBuffer.size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });
    encoder.resolveQuerySet(querySet, 0, 2, resolveBuffer, 0);
    if (resultBuffer.mapState === 'unmapped') {
      encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, resultBuffer.size);
    }
    return { resolveBuffer, resultBuffer };
}

async function timestamp(t) {
    if (t.resultBuffer.mapState === 'unmapped') {
        await t.resultBuffer.mapAsync(GPUMapMode.READ).then(() => {
            const times = new BigInt64Array(t.resultBuffer.getMappedRange());
            const gpuTime = Number(times[1] - times[0]) /  1_000_000.0;
            console.log(`elapsed time: ${gpuTime} ms.`);
            t.resultBuffer.unmap();
        });
    }
}

async function main() {
    const adapter = await navigator.gpu?.requestAdapter({
        powerPreference: 'high-performance',
    });

    const device = await adapter?.requestDevice({
        requiredFeatures: ['timestamp-query'],
    });

    if (!device) {
        alert('Your web browser does not support WebGPU');
        return;
    }

    device.addEventListener('uncapturederror', event => console.log(event.error.message));

    const initializeModule = device.createShaderModule({
        label: 'initialize module',
        code: initializeModuleCode,
    });

    const dispatchModule = device.createShaderModule({
        label: 'dispatch module',
        code: dispatchModuleCode,
    });

    const clearQueueModule = device.createShaderModule({
        label: 'clear_queue module',
        code: clearQueueModuleCode,
    });

    const sampleCameraModule = device.createShaderModule({
        label: 'sample_camera module',
        code: sampleCameraModuleCode,
    });

    const sampleLightModule = device.createShaderModule({
        label: 'sample_light module',
        code: sampleLightModuleCode,
    });

    const intersectModule = device.createShaderModule({
        label: 'intersect module',
        code: intersectModuleCode,
    });

    const buildCdfModule = device.createShaderModule({
        label: 'build_cdf module',
        code: buildCdfModuleCode,
    });

    const primaryBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: constants.cameraBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: constants.sphereBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: constants.chainBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: constants.pathStateBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: constants.imageBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: constants.queuesBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: constants.queueCountsBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });

    const auxiliaryBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: constants.dispatchIndirectParametersBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });

    const uniformsBindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: constants.uniformsBinding,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
        ],
    });

    const primaryPipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [
            primaryBindGroupLayout,
        ],
    });

    const auxiliaryPipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [
            primaryBindGroupLayout,
            auxiliaryBindGroupLayout,
        ],
    });

    const parameterizedPipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [
            primaryBindGroupLayout,
            auxiliaryBindGroupLayout,
            uniformsBindGroupLayout,
        ],
    });

    const cameraArray = configureCamera();

    const cameraBuffer = device.createBuffer({
        label: 'camera buffer',
        size: cameraArray.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(cameraBuffer, 0, cameraArray);

    const sphereArray = configureScene();

    const sphereBuffer = device.createBuffer({
        label: 'sphere buffer',
        size: sphereArray.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(sphereBuffer, 0, sphereArray);

    const chainArray = configureChains();

    const chainBuffer = device.createBuffer({
        label: 'chain buffer',
        size: chainArray.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(chainBuffer, 0, chainArray);

    const pathStateBuffer = device.createBuffer({
        label: 'path state buffer',
        size: 44 * constants.pathCount,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    });

    const imageBuffer = device.createBuffer({
        label: 'image buffer',
        size: 12 * constants.pixelWidth * constants.pixelHeight,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    const queuesBuffer = device.createBuffer({
        label: 'queues buffer',
        size: 4 * constants.queueCount * constants.pathCount,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    const queueCountsArray = configureQueueCounts();

    const queueCountsBuffer = device.createBuffer({
        label: 'queue counts buffer',
        size: queueCountsArray.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(queueCountsBuffer, 0, queueCountsArray);

    const dispatchIndirectParametersArray = configureDispatchIndirectParameters();

    const dispatchIndirectParametersBuffer = device.createBuffer({
        label: 'dispatch indirect parameters buffer',
        size: dispatchIndirectParametersArray.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.INDIRECT,
    });

    device.queue.writeBuffer(dispatchIndirectParametersBuffer, 0, dispatchIndirectParametersArray);
    
    const primaryBindGroup = device.createBindGroup({
        label: 'primary bind group',
        layout: primaryBindGroupLayout,
        entries: [
            {
                binding: constants.cameraBinding,
                resource: {
                    buffer: cameraBuffer,
                },
            },
            {
                binding: constants.sphereBinding,
                resource: {
                    buffer: sphereBuffer,
                },
            },
            {
                binding: constants.chainBinding,
                resource: {
                    buffer: chainBuffer,
                },
            },
            {
                binding: constants.pathStateBinding,
                resource: {
                    buffer: pathStateBuffer,
                },
            },
            {
                binding: constants.imageBinding,
                resource: {
                    buffer: imageBuffer,
                },
            },
            {
                binding: constants.queuesBinding,
                resource: {
                    buffer: queuesBuffer,
                },
            },
            {
                binding: constants.queueCountsBinding,
                resource: {
                    buffer: queueCountsBuffer,
                },
            },
        ],
    });

    const auxiliaryBindGroup = device.createBindGroup({
        label: 'auxiliary bind group',
        layout: auxiliaryBindGroupLayout,
        entries: [
            {
                binding: constants.dispatchIndirectParametersBinding,
                resource: {
                    buffer: dispatchIndirectParametersBuffer,
                }
            }
        ],
    });

    let uniformsArray = configureInitializeUniforms({
        path_length: 2,
    });

    let uniformsBuffer = device.createBuffer({
        label: 'uniforms buffer',
        size: uniformsArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(uniformsBuffer, 0, uniformsArray);

    let uniformsBindGroup = device.createBindGroup({
        label: 'uniforms bind group',
        layout: uniformsBindGroupLayout,
        entries: [
            {
                binding: constants.uniformsBinding,
                resource: {
                    buffer: uniformsBuffer,
                },
            },
        ],
    });

    const querySet = device.createQuerySet({
        type: 'timestamp',
        count: 2,
    });

    const initializePipeline = device.createComputePipeline({
        label: 'initialize compute pipeline',
        layout: parameterizedPipelineLayout,
        compute: {
            module: initializeModule,
        }
    });

    let encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    let pass = encoder.beginComputePass({
        label: 'initialize compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(initializePipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.setBindGroup(1, auxiliaryBindGroup);
    pass.setBindGroup(2, uniformsBindGroup);
    pass.dispatchWorkgroups(Math.ceil(constants.pathCount / constants.workgroupSize));
    pass.end();
    
    let commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    let dispatchPipeline = device.createComputePipeline({
        label: 'dispatch pipeline',
        layout: auxiliaryPipelineLayout,
        compute: {
            module: dispatchModule,
        },
    });

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'dispatch compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(dispatchPipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.setBindGroup(1, auxiliaryBindGroup);
    pass.dispatchWorkgroups(1);
    pass.end();

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    const sampleCameraPipeline = device.createComputePipeline({
        label: 'sample_camera compute pipeline',
        layout: primaryPipelineLayout,
        compute: {
            module: sampleCameraModule,
        },
    });

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'sample_camera compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(sampleCameraPipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.dispatchWorkgroupsIndirect(dispatchIndirectParametersBuffer, 16 * constants.sampleCameraQueueId);
    pass.end();

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    uniformsArray = configureClearQueueUniforms({
        queue_id: constants.sampleCameraQueueId,
    });

    uniformsBuffer = device.createBuffer({
        label: 'uniforms buffer',
        size: uniformsArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(uniformsBuffer, 0, uniformsArray);

    uniformsBindGroup = device.createBindGroup({
        label: 'uniforms bind group',
        layout: uniformsBindGroupLayout,
        entries: [
            {
                binding: constants.uniformsBinding,
                resource: {
                    buffer: uniformsBuffer,
                },
            },
        ],
    });

    const clearQueuePipeline = device.createComputePipeline({
        label: 'clear_queue pipeline',
        layout: parameterizedPipelineLayout,
        compute: {
            module: clearQueueModule,
        },
    });

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'clear_queue compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(clearQueuePipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.setBindGroup(1, auxiliaryBindGroup);
    pass.setBindGroup(2, uniformsBindGroup);
    pass.dispatchWorkgroups(1);
    pass.end();

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'dispatch compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(dispatchPipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.setBindGroup(1, auxiliaryBindGroup);
    pass.dispatchWorkgroups(1);
    pass.end();

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    const sampleLightPipeline = device.createComputePipeline({
        label: 'sample_light compute pipeline',
        layout: primaryPipelineLayout,
        compute: {
            module: sampleLightModule,
        },
    });

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'sample_light compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(sampleLightPipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.dispatchWorkgroupsIndirect(dispatchIndirectParametersBuffer, 16 * constants.sampleLightQueueId);
    pass.end();

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    uniformsArray = configureClearQueueUniforms({
        queue_id: constants.sampleLightQueueId,
    });

    uniformsBuffer = device.createBuffer({
        label: 'uniforms buffer',
        size: uniformsArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(uniformsBuffer, 0, uniformsArray);

    uniformsBindGroup = device.createBindGroup({
        label: 'uniforms bind group',
        layout: uniformsBindGroupLayout,
        entries: [
            {
                binding: constants.uniformsBinding,
                resource: {
                    buffer: uniformsBuffer,
                },
            },
        ],
    });

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'clear_queue compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(clearQueuePipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.setBindGroup(1, auxiliaryBindGroup);
    pass.setBindGroup(2, uniformsBindGroup);
    pass.dispatchWorkgroups(1);
    pass.end();

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    const intersectPipeline = device.createComputePipeline({
        label: 'intersect compute pipeline',
        layout: primaryPipelineLayout,
        compute: {
            module: intersectModule,
        },
    });

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'intersect compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(intersectPipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.dispatchWorkgroupsIndirect(dispatchIndirectParametersBuffer, 16 * constants.intersectQueueId);
    pass.end();

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    const buildCdfPipeline = device.createComputePipeline({
        label: 'build_cdf compute pipeline',
        layout: parameterizedPipelineLayout,
        compute: {
            module: buildCdfModule,
        },
    });

    encoder = device.createCommandEncoder({
        label: 'command encoder',
    });

    pass = encoder.beginComputePass({
        label: 'build_cdf compute pass',
        timestampWrites: {
            querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1,
        },
    });
    pass.setPipeline(buildCdfPipeline);
    pass.setBindGroup(0, primaryBindGroup);
    pass.setBindGroup(1, auxiliaryBindGroup);

    for (let i = 0; i < Math.ceil(Math.log2(constants.pathCount)); i++) {
        uniformsArray = configureBuildCdfUniforms({
            min_path_index: 0,
            path_count: constants.pathCount,
            iteration: i,
        });
    
        uniformsBuffer = device.createBuffer({
            label: 'uniforms buffer',
            size: uniformsArray.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
    
        device.queue.writeBuffer(uniformsBuffer, 0, uniformsArray);
    
        uniformsBindGroup = device.createBindGroup({
            label: 'uniforms bind group',
            layout: uniformsBindGroupLayout,
            entries: [
                {
                    binding: constants.uniformsBinding,
                    resource: {
                        buffer: uniformsBuffer,
                    },
                },
            ],
        });

        pass.setBindGroup(2, uniformsBindGroup);
        pass.dispatchWorkgroups(Math.ceil(constants.pathCount / constants.workgroupSize));
    }

    pass.end();

    const d = prepareDebug(device, pathStateBuffer, encoder, getPathStateArrayViews, 'path state');
    const t = prepareTimestamp(device, querySet, encoder);

    commandBuffer = encoder.finish();
    device.queue.submit([commandBuffer]);

    await debug(d);
    await timestamp(t);
}

main();

    </script>
</html>
